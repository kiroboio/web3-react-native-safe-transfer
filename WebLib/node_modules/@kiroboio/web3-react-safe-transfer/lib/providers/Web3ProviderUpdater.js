"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3ProviderUpdater = void 0;
var react_1 = __importStar(require("react"));
var web3_1 = __importDefault(require("web3"));
var web3_utils_1 = require("web3-utils");
var account_1 = require("../context/account");
var useWeb3_1 = require("../hooks/useWeb3");
var safe_transfer_lib_lite_1 = __importDefault(require("@kiroboio/safe-transfer-lib-lite"));
var mobx_react_lite_1 = require("mobx-react-lite");
var safeTransfer_json_1 = __importDefault(require("../abi/safeTransfer.json"));
var erc20_json_1 = __importDefault(require("../abi/erc20.json"));
var safeSwap_json_1 = __importDefault(require("../abi/safeSwap.json"));
var useWeb3_2 = require("../hooks/useWeb3");
var useWallet_1 = require("../hooks/useWallet");
require("@metamask/detect-provider");
var InAppWalletConnector_1 = __importDefault(require("../customConnectors/InAppWalletConnector"));
var ua_parser_js_1 = require("ua-parser-js");
var MAX_CONFIRMS = 30;
var SERVICE = {
    RATES: 'v1/eth/to/usd',
    TOKEN_RATES: 'v1/eth/erc20/rates',
    NETWORKS: 'v1/eth/networks',
    REWARDS: function (network) {
        return "v1/eth/" + network + "/rewards";
    },
    BALANCE: function (network) {
        return "v1/eth/" + network + "/balance";
    },
    TRANSFERS: function (network) {
        return "v1/eth/" + network + "/transfers";
    },
    TRANSFER_REQUEST: function (network) {
        return "v1/eth/" + network + "/transfer/request";
    },
    FOLLOW: function (network) {
        return "v1/eth/" + network + "/action/follow";
    },
    COLLECT: function (network) {
        return "v1/eth/" + network + "/action/collect";
    },
    SWAP: function (network) {
        return "v1/eth/" + network + "/action/swap";
    },
    ERC20: function (network) {
        return "v1/eth/" + network + "/erc20";
    },
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var usePrevious = function (value) {
    var ref = react_1.useRef();
    react_1.useEffect(function () {
        ref.current = value;
    });
    return ref.current;
};
var getChainName = function (chainId) {
    if (chainId === 1)
        return 'main';
    if (chainId === 4)
        return 'rinkeby';
    return '';
};
var responseToTransferItem = function (item) {
    var _a;
    var confirmedBlock = item.state === 'new'
        ? item.deposit.confirmed
        : item.state === 'collected'
            ? item.collect.confirmed
            : item.state === 'retrieved'
                ? item.retrieve.confirmed
                : item.state === 'swapped'
                    ? item.swap.confirmed
                    : -1;
    var txid = ((_a = item.swap) === null || _a === void 0 ? void 0 : _a.txid) ||
        item.collect.txid ||
        item.retrieve.txid ||
        item.deposit.txid ||
        item.swap.txid;
    return {
        id: item.id,
        txid: txid,
        from: item.from,
        to: item.to,
        value: item.value,
        fees: item.fees,
        salt: item.salt,
        secretHash: item.secretHash,
        state: item.state,
        updatedAt: new Date(item.updatedAt),
        confirmedBlock: confirmedBlock,
        message: item.message,
        token: item.token,
        swap: item.interchange,
    };
};
var moveToStore = function (_a) {
    var store = _a.store, address = _a.address, item = _a.item;
    store.upsert(address, item);
};
var putInStore = function (_a) {
    var store = _a.store, address = _a.address, item = _a.item;
    store.upsert(address, responseToTransferItem(item));
};
var addToStore = function (_a) {
    var store = _a.store, address = _a.address, items = _a.items, count = _a.count;
    store.add({
        address: address,
        count: count,
        transfers: items.map(function (item) { return responseToTransferItem(item); }),
    });
};
var inboxQuery = function (_a) {
    var address = _a.address, thresholdBlock = _a.thresholdBlock, $skip = _a.$skip, $limit = _a.$limit, watch = _a.watch;
    return ({
        address: address,
        type: 'incoming',
        state: {
            $in: [
                'new',
                'creating',
                'retrieved',
                'retrieving',
                'collected',
                'collecting',
            ],
        },
        $or: [
            { 'collect.confirmed': -1, 'retrieve.confirmed': -1 },
            { 'collect.confirmed': { $gt: thresholdBlock } },
            { 'retrieve.confirmed': { $gt: thresholdBlock } },
        ],
        $sort: { updatedAt: -1 },
        $skip: $skip,
        $limit: $limit,
        watch: watch,
    });
};
var outboxQuery = function (_a) {
    var address = _a.address, thresholdBlock = _a.thresholdBlock, $skip = _a.$skip, $limit = _a.$limit, watch = _a.watch;
    return ({
        address: address,
        type: 'outgoing',
        state: {
            $in: [
                'new',
                'creating',
                'retrieved',
                'retrieving',
                'collected',
                'collecting',
                'unknown',
            ],
        },
        $or: [
            { 'collect.confirmed': -1, 'retrieve.confirmed': -1 },
            { 'collect.confirmed': { $gt: thresholdBlock } },
            { 'retrieve.confirmed': { $gt: thresholdBlock } },
        ],
        $sort: { updatedAt: -1 },
        $skip: $skip,
        $limit: $limit,
        watch: watch,
    });
};
var transfersQuery = function (_a) {
    var address = _a.address, thresholdBlock = _a.thresholdBlock, $skip = _a.$skip, $limit = _a.$limit, watch = _a.watch;
    return ({
        address: address,
        service: 'transfer',
        state: {
            $in: [
                'new',
                'creating',
                'retrieved',
                'retrieving',
                'collected',
                'collecting',
                'unknown',
            ],
        },
        $or: [
            { 'collect.confirmed': -1, 'retrieve.confirmed': -1 },
            { 'collect.confirmed': { $gt: thresholdBlock } },
            { 'retrieve.confirmed': { $gt: thresholdBlock } },
        ],
        $sort: { updatedAt: -1 },
        $skip: $skip,
        $limit: $limit,
        watch: watch,
    });
};
var swapsQuery = function (_a) {
    var address = _a.address, thresholdBlock = _a.thresholdBlock, $skip = _a.$skip, $limit = _a.$limit, watch = _a.watch;
    return ({
        address: address,
        service: 'swap',
        state: {
            $in: [
                'new',
                'creating',
                'retrieved',
                'retrieving',
                'swapped',
                'swapping',
                'unknown',
            ],
        },
        $or: [
            { 'swap.confirmed': -1, 'retrieve.confirmed': -1 },
            { 'swap.confirmed': { $gt: thresholdBlock } },
            { 'retrieve.confirmed': { $gt: thresholdBlock } },
        ],
        $sort: { updatedAt: -1 },
        $skip: $skip,
        $limit: $limit,
        watch: watch,
    });
};
var historyQuery = function (_a) {
    var address = _a.address, thresholdBlock = _a.thresholdBlock, $skip = _a.$skip, $limit = _a.$limit, watch = _a.watch;
    return ({
        address: address,
        $or: [
            { 'collect.confirmed': { $gt: -1, $lte: thresholdBlock } },
            { 'retrieve.confirmed': { $gt: -1, $lte: thresholdBlock } },
            { 'swap.confirmed': { $gt: -1, $lte: thresholdBlock } },
        ],
        $sort: { updatedAt: -1 },
        $skip: $skip,
        $limit: $limit,
        watch: watch,
    });
};
var deleteFromStore = function (_a) {
    var store = _a.store, address = _a.address, id = _a.id;
    store.delete(address, id);
};
var removeFromStore = function (_a) {
    var store = _a.store, address = _a.address, filter = _a.filter;
    return store.remove(address, filter);
};
exports.Web3ProviderUpdater = mobx_react_lite_1.observer(function (_a) {
    var _b;
    var children = _a.children;
    var _c = useWeb3_1.useWeb3(), web3Connect = _c.connect, web3Connector = _c.connector, web3Disconnect = _c.disconnect, web3 = _c.library, web3Active = _c.active, web3ChainId = _c.chainId, web3Address = _c.address, web3Activate = _c.activate;
    var _d = account_1.useAccount(), active = _d.active, setActive = _d.setActive, connectCmd = _d.connectCmd, disconnectCmd = _d.disconnectCmd, address = _d.address, swapperAddress = _d.swapperAddress, setSwapperBalance = _d.setSwapperBalance, setAddress = _d.setAddress, setCanGetRewards = _d.setCanGetRewards, chainId = _d.chainId, setChainId = _d.setChainId, block = _d.block, setBlock = _d.setBlock, setBalance = _d.setBalance, setGasPrice = _d.setGasPrice, setMaxRewards = _d.setMaxRewards, setRewardsParams = _d.setRewardsParams, setTokenBalance = _d.setTokenBalance, setStakingBalance = _d.setStakingBalance, setRate = _d.setRate, approvedCmd = _d.approvedCmd, depositCmd = _d.depositCmd, swapDepositCmd = _d.swapDepositCmd, retrieveCmd = _d.retrieveCmd, swapRetrieveCmd = _d.swapRetrieveCmd, collectCmd = _d.collectCmd, swapCmd = _d.swapCmd, history = _d.history, swaps = _d.swaps, transfers = _d.transfers, incoming = _d.incoming, outgoing = _d.outgoing, safeTransferContract = _d.safeTransferContract, setSafeTransferContract = _d.setSafeTransferContract, safeSwapContract = _d.safeSwapContract, setSafeSwapContract = _d.setSafeSwapContract, setStakingContract = _d.setStakingContract, setKiroTokenContract = _d.setKiroTokenContract, setERC20TokenContract = _d.setERC20TokenContract, setERC20TokenBalance = _d.setERC20TokenBalance, setErc20TokenRate = _d.setErc20TokenRate, clearERC20TokenBalances = _d.clearERC20TokenBalances, ERC20TokenList = _d.ERC20TokenList, setCurrencyBalance = _d.setCurrencyBalance, currency = _d.currency, desiredCurrency = _d.desiredCurrency, setCurrency = _d.setCurrency, setDesiredCurrency = _d.setDesiredCurrency, setAllowance = _d.setAllowance, formType = _d.formType, setDeviceInfo = _d.setDeviceInfo, wallet = _d.wallet, gasPriceMap = _d.gasPriceMap;
    var _e = useWallet_1.useWallet(), getMnemonic = _e.getMnemonic, setNewMnemonic = _e.setNewMnemonic, generateNewMnemonic = _e.generateNewMnemonic, getActiveAccountFromStorage = _e.getActiveAccountFromStorage, setActiveAccount = _e.setActiveAccount;
    var _f = react_1.useState(false), status = _f[0], setStatus = _f[1];
    var _g = react_1.useState(0), heightMain = _g[0], setHeightMain = _g[1];
    var _h = react_1.useState(0), heightRinkeby = _h[0], setHeightRinkeby = _h[1];
    var prevBlock = usePrevious(block);
    var prevAddress = usePrevious(address);
    var prevChainId = usePrevious(chainId);
    var prevStatus = usePrevious(status);
    var _j = react_1.useState(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new new web3_1.default().eth.Contract(erc20_json_1.default)), erc20TokenContractWeb3 = _j[0], setErc20TokenContractWeb3 = _j[1];
    var _k = react_1.useState(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new new web3_1.default().eth.Contract(safeTransfer_json_1.default)), safeTransferContractWeb3 = _k[0], setSafeTransferContractWeb3 = _k[1];
    var _l = react_1.useState(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new new web3_1.default().eth.Contract(safeSwap_json_1.default)), safeSwapContractWeb3 = _l[0], setSafeSwapContractWeb3 = _l[1];
    var fetchNextTransfers = react_1.useCallback(function (_a) {
        var store = _a.store, queryBuilder = _a.queryBuilder, thresholdBlock = _a.thresholdBlock, _b = _a.watch, watch = _b === void 0 ? 'ignore' : _b;
        var fetchTransfers = function (_a) {
            var store = _a.store, query = _a.query;
            var service = safe_transfer_lib_lite_1.default.getInstance();
            if (!service) {
                store.fetchCmd.done();
                return;
            }
            var network = getChainName(chainId < 1 ? 1 : chainId);
            if (network && block) {
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).find({ query: query }).then(function (payload) {
                    store.fetchCmd.done();
                    addToStore({
                        store: store,
                        address: address,
                        items: payload.data,
                        count: payload.total,
                    });
                    store.setFetched(payload.skip + payload.data.length);
                }).catch(function () {
                    store.fetchCmd.done();
                });
            }
            else {
                store.fetchCmd.done();
            }
        };
        if (store.fetchCmd.is.ready && !store.fetchCmd.is.running) {
            store.fetchCmd.start();
            if (store.fetched === 0 || store.fetched < store.count) {
                fetchTransfers({
                    store: store,
                    query: queryBuilder({
                        address: address,
                        $limit: store.fetchCmd.amount,
                        $skip: store.fetched,
                        watch: watch,
                        thresholdBlock: thresholdBlock,
                    }),
                });
            }
            else {
                store.fetchCmd.done();
            }
        }
    }, [address, block, chainId]);
    var __block = react_1.useRef(block);
    var __transfers = react_1.useRef(transfers);
    var __incoming = react_1.useRef(incoming);
    var __outgoing = react_1.useRef(outgoing);
    var __history = react_1.useRef(history);
    var __swaps = react_1.useRef(swaps);
    var __fetchNextTransfers = react_1.useRef(fetchNextTransfers);
    var __prevAddress = react_1.useRef(prevAddress);
    var __prevChainId = react_1.useRef(prevChainId);
    var __prevBlock = react_1.useRef(prevBlock);
    var __prevStatus = react_1.useRef(prevStatus);
    var __setBalance = react_1.useRef(setBalance);
    var __setGasPrice = react_1.useRef(setGasPrice);
    var __setMaxRewards = react_1.useRef(setMaxRewards);
    var __setRewardsParams = react_1.useRef(setRewardsParams);
    var __setStakingBalance = react_1.useRef(setStakingBalance);
    var __setTokenBalance = react_1.useRef(setTokenBalance);
    var __setBlock = react_1.useRef(setBlock);
    var __active = react_1.useRef(active);
    var __address = react_1.useRef(address);
    var __swapperAddress = react_1.useRef(swapperAddress);
    var __setSwapperBalance = react_1.useRef(setSwapperBalance);
    var __chainId = react_1.useRef(chainId);
    var __connectCmd = react_1.useRef(connectCmd);
    var __disconnectCmd = react_1.useRef(disconnectCmd);
    var __depositCmd = react_1.useRef(depositCmd);
    var __swapDepositCmd = react_1.useRef(swapDepositCmd);
    var __approvedCmd = react_1.useRef(approvedCmd);
    var __collectCmd = react_1.useRef(collectCmd);
    var __swapCmd = react_1.useRef(swapCmd);
    var __retrieveCmd = react_1.useRef(retrieveCmd);
    var __swapRetrieveCmd = react_1.useRef(swapRetrieveCmd);
    var __erc20TokenContractWeb3 = react_1.useRef(erc20TokenContractWeb3);
    var __safeTransferContractWeb3 = react_1.useRef(safeTransferContractWeb3);
    var __safeSwapContractWeb3 = react_1.useRef(safeSwapContractWeb3);
    var __web3 = react_1.useRef(web3);
    var __setRate = react_1.useRef(setRate);
    var __setSafeTransferContract = react_1.useRef(setSafeTransferContract);
    var __safeTransferContract = react_1.useRef(safeTransferContract);
    var __setSafeSwapContract = react_1.useRef(setSafeSwapContract);
    var __safeSwapContract = react_1.useRef(safeSwapContract);
    var __setStakingContract = react_1.useRef(setStakingContract);
    var __setDeviceInfo = react_1.useRef(setDeviceInfo);
    var __setKiroTokenContract = react_1.useRef(setKiroTokenContract);
    var __setERC20TokenContract = react_1.useRef(setERC20TokenContract);
    var __setERC20TokenBalance = react_1.useRef(setERC20TokenBalance);
    var __setErc20TokenRate = react_1.useRef(setErc20TokenRate);
    var __setCurrencyBalance = react_1.useRef(setCurrencyBalance);
    var __clearERC20TokenBalances = react_1.useRef(clearERC20TokenBalances);
    var __ERC20TokenList = react_1.useRef(ERC20TokenList);
    var __gasPriceMap = react_1.useRef(gasPriceMap);
    var __web3Connect = react_1.useRef(web3Connect);
    var __web3Connector = react_1.useRef(web3Connector);
    var __web3Disconnect = react_1.useRef(web3Disconnect);
    var __setActive = react_1.useRef(setActive);
    var __setAddress = react_1.useRef(setAddress);
    var __setCanGetRewards = react_1.useRef(setCanGetRewards);
    var __setChainId = react_1.useRef(setChainId);
    var __setNewMnemonic = react_1.useRef(setNewMnemonic);
    var __getMnemonic = react_1.useRef(getMnemonic);
    var __generateNewMnemonic = react_1.useRef(generateNewMnemonic);
    var __getActiveAccountFromStorage = react_1.useRef(getActiveAccountFromStorage);
    var __wallet = react_1.useRef(wallet);
    var __web3Activate = react_1.useRef(web3Activate);
    var __setActiveAccount = react_1.useRef(setActiveAccount);
    var __currency = react_1.useRef(currency);
    var __desiredCurrency = react_1.useRef(desiredCurrency);
    var __setCurrency = react_1.useRef(setCurrency);
    var __setDesiredCurrency = react_1.useRef(setDesiredCurrency);
    var __setAllowance = react_1.useRef(setAllowance);
    var __formType = react_1.useRef(formType);
    react_1.useEffect(function () {
        __block.current = block;
        __swapperAddress.current = swapperAddress;
        __setSwapperBalance.current = setSwapperBalance;
        __transfers.current = transfers;
        __incoming.current = incoming;
        __outgoing.current = outgoing;
        __history.current = history;
        __swaps.current = swaps;
        __fetchNextTransfers.current = fetchNextTransfers;
        __prevAddress.current = prevAddress;
        __prevChainId.current = prevChainId;
        __prevBlock.current = prevBlock;
        __prevStatus.current = prevStatus;
        __setBalance.current = setBalance;
        __setGasPrice.current = setGasPrice;
        __setMaxRewards.current = setMaxRewards;
        __setRewardsParams.current = setRewardsParams;
        __setTokenBalance.current = setTokenBalance;
        __setStakingBalance.current = setStakingBalance;
        __setBlock.current = setBlock;
        __active.current = active;
        __address.current = address;
        __chainId.current = chainId;
        __connectCmd.current = connectCmd;
        __disconnectCmd.current = disconnectCmd;
        __approvedCmd.current = approvedCmd;
        __depositCmd.current = depositCmd;
        __swapDepositCmd.current = swapDepositCmd;
        __collectCmd.current = collectCmd;
        __swapCmd.current = swapCmd;
        __retrieveCmd.current = retrieveCmd;
        __swapRetrieveCmd.current = swapRetrieveCmd;
        __erc20TokenContractWeb3.current = erc20TokenContractWeb3;
        __safeTransferContractWeb3.current = safeTransferContractWeb3;
        __safeSwapContractWeb3.current = safeSwapContractWeb3;
        __web3.current = web3;
        __setRate.current = setRate;
        __setSafeTransferContract.current = setSafeTransferContract;
        __safeTransferContract.current = safeTransferContract;
        __setSafeSwapContract.current = setSafeSwapContract;
        __safeSwapContract.current = safeSwapContract;
        __setCurrency.current = setCurrency;
        __setDesiredCurrency.current = setDesiredCurrency;
        __setAllowance.current = setAllowance;
        __formType.current = formType;
        __setStakingContract.current = setStakingContract;
        __setDeviceInfo.current = setDeviceInfo;
        __setKiroTokenContract.current = setKiroTokenContract;
        __setERC20TokenContract.current = setERC20TokenContract;
        __setERC20TokenBalance.current = setERC20TokenBalance;
        __setErc20TokenRate.current = setErc20TokenRate;
        __setCurrencyBalance.current = setCurrencyBalance;
        __currency.current = currency;
        __desiredCurrency.current = desiredCurrency;
        __clearERC20TokenBalances.current = clearERC20TokenBalances;
        __ERC20TokenList.current = ERC20TokenList;
        __gasPriceMap.current = gasPriceMap;
        __web3Connect.current = web3Connect;
        __web3Disconnect.current = web3Disconnect;
        __web3Connector.current = web3Connector;
        __web3Activate.current = web3Activate;
        __setActive.current = setActive;
        __setAddress.current = setAddress;
        __setCanGetRewards.current = setCanGetRewards;
        __setChainId.current = setChainId;
        __setNewMnemonic.current = setNewMnemonic;
        __generateNewMnemonic.current = generateNewMnemonic;
        __getMnemonic.current = getMnemonic;
        __wallet.current = wallet;
        __setActiveAccount.current = setActiveAccount;
    });
    react_1.useEffect(function () {
        var setNewMnemonic = __setNewMnemonic.current;
        if (!wallet.mnemonic.data)
            return;
        setNewMnemonic(wallet.mnemonic.data);
    }, [wallet.mnemonic.data]);
    react_1.useEffect(function () {
        var web3Connector = __web3Connector.current;
        var wallet = __wallet.current;
        if (!wallet.addAddressCmd.is.ready || wallet.addAddressCmd.is.running)
            return;
        try {
            wallet.addAddressCmd.start();
            if (!wallet.mnemonic.data)
                throw new Error('no mnemonic');
            if (!web3Connector)
                throw new Error('connector not started');
            if (!(web3Connector === null || web3Connector === void 0 ? void 0 : web3Connector.addWalletAddress))
                throw new Error('wrong connector');
            web3Connector === null || web3Connector === void 0 ? void 0 : web3Connector.addWalletAddress();
            wallet.addAddressCmd.done();
        }
        catch (e) {
            wallet.addAddressCmd.failed({ message: e.message || e.reason });
        }
    }, [wallet.addAddressCmd.is.ready]);
    react_1.useEffect(function () {
        var web3Connector = __web3Connector.current;
        var wallet = __wallet.current;
        if (!wallet.removeAddressCmd.is.ready || wallet.removeAddressCmd.is.running)
            return;
        try {
            wallet.removeAddressCmd.start();
            if (!wallet.mnemonic.data)
                throw new Error('no mnemonic');
            if (!web3Connector)
                throw new Error('connector not started');
            if (!(web3Connector === null || web3Connector === void 0 ? void 0 : web3Connector.removeWalletAddress))
                throw new Error('wrong connector');
            web3Connector === null || web3Connector === void 0 ? void 0 : web3Connector.removeWalletAddress(wallet.removeAddressCmd.address);
            wallet.removeAddressCmd.done();
        }
        catch (e) {
            wallet.removeAddressCmd.failed({ message: e.message || e.reason });
        }
    }, [wallet.removeAddressCmd.is.ready]);
    react_1.useEffect(function () {
        var setNewMnemonic = __setNewMnemonic.current;
        var wallet = __wallet.current;
        var mnemonic = __getMnemonic.current();
        if (!wallet.mnemonic.restoreCmd.is.ready ||
            wallet.mnemonic.restoreCmd.is.running)
            return;
        try {
            wallet.mnemonic.restoreCmd.start();
            if (!mnemonic) {
                throw new Error('no mnemonic');
            }
            wallet.mnemonic.set(mnemonic);
            setNewMnemonic(mnemonic);
            wallet.mnemonic.restoreCmd.done();
        }
        catch (e) {
            wallet.mnemonic.restoreCmd.failed({ message: e.message || e.reason });
        }
    }, [wallet.mnemonic.restoreCmd.is.ready]);
    var web3WalletAddressesAmount = ((_b = __web3.current) === null || _b === void 0 ? void 0 : _b.eth.accounts.wallet)
        ? Object.keys(__web3.current.eth.accounts.wallet)
        : null;
    react_1.useEffect(function () {
        var wallet = __wallet.current;
        var connectCmd = __connectCmd.current;
        var web3 = __web3.current;
        if (connectCmd.connector !== useWeb3_2.Connectors.InAppWallet)
            return;
        if (!connectCmd.is.done || !wallet.mnemonic.data)
            return;
        var accounts = new Set();
        Object.keys(web3.eth.accounts.wallet).forEach(function (key) {
            var _a;
            if (!((_a = web3.eth.accounts.wallet[parseInt(key)]) === null || _a === void 0 ? void 0 : _a.address))
                return;
            accounts.add(web3.eth.accounts.wallet[parseInt(key)].address);
        });
        var uniqueAccountsArray = Array.from(accounts);
        if (!uniqueAccountsArray.includes(wallet.activeAccount)) {
            wallet.setActiveAccount(uniqueAccountsArray[0]);
            InAppWalletConnector_1.default.setActiveAccount(uniqueAccountsArray[0]);
        }
        else {
            wallet.setActiveAccount(wallet.activeAccount);
            InAppWalletConnector_1.default.setActiveAccount(wallet.activeAccount);
        }
        wallet.setAccounts(uniqueAccountsArray);
    }, [wallet.mnemonic.data, web3WalletAddressesAmount]);
    react_1.useEffect(function () {
        var wallet = __wallet.current;
        var activeAccount = __getActiveAccountFromStorage.current();
        if (!activeAccount)
            return;
        wallet.setActiveAccount(activeAccount);
        InAppWalletConnector_1.default.setActiveAccount(activeAccount);
    }, []);
    react_1.useEffect(function () {
        var wallet = __wallet.current;
        var web3Connector = __web3Connector.current;
        var setActiveAccount = __setActiveAccount.current;
        if (!(web3Connector === null || web3Connector === void 0 ? void 0 : web3Connector.handleAccountChanged))
            return;
        web3Connector.handleAccountChanged(wallet.activeAccount);
        setActiveAccount(wallet.activeAccount);
    }, [wallet.activeAccount]);
    react_1.useEffect(function () {
        var web3 = __web3.current;
        var chainId = __chainId.current;
        var currency = __currency.current;
        var safeSwapContract = __safeSwapContract.current;
        var safeTransferContract = __safeTransferContract.current;
        var setTokenBalance = __setTokenBalance.current;
        if (currency.symbol !== 'ETH') {
            ;
            (function checkAllowance() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, erc20TokenContractWeb3_1, contract, allowance, e_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 3, , 4]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId);
                                setTokenBalance(currency.balance);
                                return [4 /*yield*/, setErc20TokenContractWeb3(new web3.eth.Contract(
                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    erc20_json_1.default, currency.address))];
                            case 1:
                                _a.sent();
                                erc20TokenContractWeb3_1 = __erc20TokenContractWeb3.current;
                                if (!service)
                                    throw new Error('service not started');
                                if (!__active.current)
                                    throw new Error('web3 not connected');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!erc20TokenContractWeb3_1)
                                    throw new Error('erc20Token contract not found');
                                contract = formType === 'swap' ? safeSwapContract : safeTransferContract;
                                return [4 /*yield*/, erc20TokenContractWeb3_1.methods
                                        .allowance(address, contract === null || contract === void 0 ? void 0 : contract.address)
                                        .call()];
                            case 2:
                                allowance = _a.sent();
                                __setAllowance.current(allowance);
                                return [3 /*break*/, 4];
                            case 3:
                                e_1 = _a.sent();
                                console.log("check allowance failed: " + (e_1.message || e_1.reason));
                                return [3 /*break*/, 4];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
        else {
            var network = getChainName(chainId);
            var kiroToken = __ERC20TokenList
                .current(network)
                .find(function (token) { return (token === null || token === void 0 ? void 0 : token.symbol) === 'KIRO'; });
            if (kiroToken === null || kiroToken === void 0 ? void 0 : kiroToken.balance)
                setTokenBalance(kiroToken === null || kiroToken === void 0 ? void 0 : kiroToken.balance);
        }
    }, [currency.symbol, currency.address, connectCmd.is.done, formType, address]);
    react_1.useEffect(function () {
        var web3 = __web3.current;
        var active = __active.current;
        var chainId = __chainId.current;
        var address = __address.current;
        var approvedCmd = __approvedCmd.current;
        var erc20TokenContractWeb3 = __erc20TokenContractWeb3.current;
        var currency = __currency.current;
        if (approvedCmd.is.ready &&
            !approvedCmd.is.running &&
            currency.symbol !== 'ETH') {
            approvedCmd.start();
            (function runApprovedCmd() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, amount, gasPrice, gas, _a, approve, allowance, e_2;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _b.trys.push([0, 5, , 6]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId);
                                amount = approvedCmd.amount;
                                if (!service)
                                    throw new Error('service not started');
                                if (!active)
                                    throw new Error('web3 not connected');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!erc20TokenContractWeb3)
                                    throw new Error('erc20Token contract not found');
                                gasPrice = gasPriceMap.get(network);
                                _a = web3_utils_1.toBN;
                                return [4 /*yield*/, erc20TokenContractWeb3.methods
                                        .approve(approvedCmd.contractAddress, web3.utils.toBN(amount))
                                        .estimateGas({ from: address })];
                            case 1:
                                gas = _a.apply(void 0, [_b.sent()])
                                    .mul(web3_utils_1.toBN(11))
                                    .div(web3_utils_1.toBN(10))
                                    .toString();
                                return [4 /*yield*/, erc20TokenContractWeb3.methods
                                        .approve(approvedCmd.contractAddress, web3.utils.toBN(amount))
                                        .send({ from: address, gasPrice: gasPrice, gas: gas })];
                            case 2:
                                approve = _b.sent();
                                if (!approve) return [3 /*break*/, 4];
                                return [4 /*yield*/, erc20TokenContractWeb3.methods
                                        .allowance(address, approvedCmd.contractAddress)
                                        .call()];
                            case 3:
                                allowance = _b.sent();
                                __setAllowance.current(allowance);
                                _b.label = 4;
                            case 4:
                                approvedCmd.done();
                                return [3 /*break*/, 6];
                            case 5:
                                e_2 = _b.sent();
                                approvedCmd.failed({ message: e_2.message || e_2.reason });
                                return [3 /*break*/, 6];
                            case 6: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
    }, [approvedCmd.is.ready]);
    // on account.deposit command
    react_1.useEffect(function () {
        var active = __active.current;
        var address = __address.current;
        var chainId = __chainId.current;
        var depositCmd = __depositCmd.current;
        var safeTransferContractWeb3 = __safeTransferContractWeb3.current;
        if (depositCmd.is.ready && !depositCmd.is.running) {
            depositCmd.start();
            (function runDepositCmd() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, from, to_1, value_1, publicSalt, privateSalt, secretHash_1, message, serviceRequestParams, currency_1, request_1, total_1, gasPrice, gas, _a, _b, sendPayload_1, _c, txid, _d, hex, item, e_3;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                _e.trys.push([0, 13, , 14]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId);
                                from = depositCmd.from, to_1 = depositCmd.to, value_1 = depositCmd.value, publicSalt = depositCmd.publicSalt, privateSalt = depositCmd.privateSalt, secretHash_1 = depositCmd.secretHash, message = depositCmd.message;
                                if (!service)
                                    throw new Error('service not started');
                                if (!active)
                                    throw new Error('web3 not connected');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!safeTransferContractWeb3)
                                    throw new Error('safeTransfer contract not found');
                                if (from !== address)
                                    throw new Error('from does not match address');
                                serviceRequestParams = {
                                    from: from,
                                    to: to_1,
                                    value: value_1,
                                    publicSalt: publicSalt,
                                    privateSalt: privateSalt,
                                    secretHash: secretHash_1,
                                    message: message,
                                };
                                currency_1 = __currency.current;
                                if (currency_1.symbol !== 'ETH') {
                                    serviceRequestParams.token = {
                                        address: currency_1.address,
                                        decimals: currency_1.decimals,
                                        symbol: currency_1.symbol,
                                        type: 'ERC20',
                                    };
                                }
                                return [4 /*yield*/, service
                                        .getService(SERVICE.TRANSFER_REQUEST(network))
                                        .create(serviceRequestParams)];
                            case 1:
                                request_1 = _e.sent();
                                total_1 = web3_utils_1.toBN(value_1).add(web3_utils_1.toBN(request_1.fees));
                                gasPrice = gasPriceMap.get(network);
                                _a = web3_utils_1.toBN;
                                if (!(currency_1.symbol !== 'ETH')) return [3 /*break*/, 3];
                                return [4 /*yield*/, safeTransferContractWeb3.methods
                                        .depositERC20(currency_1.address, currency_1.symbol, to_1, value_1, request_1.fees, secretHash_1)
                                        .estimateGas({ from: address, value: request_1.fees })];
                            case 2:
                                _b = _e.sent();
                                return [3 /*break*/, 5];
                            case 3: return [4 /*yield*/, safeTransferContractWeb3.methods
                                    .deposit(to_1, value_1, request_1.fees, secretHash_1)
                                    .estimateGas({ from: address, value: total_1 })];
                            case 4:
                                _b = _e.sent();
                                _e.label = 5;
                            case 5:
                                gas = _a.apply(void 0, [_b])
                                    .mul(web3_utils_1.toBN(11))
                                    .div(web3_utils_1.toBN(10))
                                    .toString();
                                sendPayload_1 = {
                                    from: from,
                                    gasPrice: gasPrice,
                                    gas: gas,
                                };
                                if (!(connectCmd.connector !== useWeb3_2.Connectors.InAppWallet)) return [3 /*break*/, 7];
                                _c = sendPayload_1;
                                return [4 /*yield*/, __web3.current.eth.getTransactionCount(address, 'pending')];
                            case 6:
                                _c.nonce = _e.sent();
                                _e.label = 7;
                            case 7:
                                if (!(currency_1.symbol !== 'ETH')) return [3 /*break*/, 9];
                                return [4 /*yield*/, new Promise(function (resolve, reject) {
                                        safeTransferContractWeb3.methods
                                            .depositERC20(currency_1.address, currency_1.symbol, to_1, value_1, request_1.fees, secretHash_1)
                                            .send(__assign(__assign({}, sendPayload_1), { value: request_1.fees }))
                                            .on('transactionHash', function (hash) { return resolve(hash); })
                                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            .on('error', function (err) { return reject(err); });
                                    })];
                            case 8:
                                _d = _e.sent();
                                return [3 /*break*/, 11];
                            case 9: return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    safeTransferContractWeb3.methods
                                        .deposit(to_1, value_1, request_1.fees, secretHash_1)
                                        .send(__assign(__assign({}, sendPayload_1), { value: total_1 }))
                                        .on('transactionHash', function (hash) { return resolve(hash); })
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        .on('error', function (err) { return reject(err); });
                                })];
                            case 10:
                                _d = _e.sent();
                                _e.label = 11;
                            case 11:
                                txid = _d;
                                hex = currency_1.symbol !== 'ETH'
                                    ? safeTransferContractWeb3.methods
                                        .depositERC20(currency_1.address, currency_1.symbol, to_1, value_1, request_1.fees, secretHash_1)
                                        .encodeABI()
                                    : safeTransferContractWeb3.methods
                                        .deposit(to_1, value_1, request_1.fees, secretHash_1)
                                        .encodeABI();
                                return [4 /*yield*/, service.getService(SERVICE.FOLLOW(network)).create({
                                        txid: txid,
                                        hex: hex,
                                    })];
                            case 12:
                                _e.sent();
                                item = __assign(__assign({}, request_1), { collect: { broadcasted: -1, confirmed: -1, txid: '' }, deposit: { txid: txid, broadcasted: -1, confirmed: -1 }, expires: { at: request_1.expiresAt }, state: 'creating', retrieve: { broadcasted: -1, confirmed: -1, txid: '' }, message: message,
                                    txid: txid, salt: request_1.publicSalt, updatedAt: request_1.createdAt, token: currency_1.symbol !== 'ETH'
                                        ? {
                                            address: currency_1.address,
                                            decimals: currency_1.decimals,
                                            symbol: currency_1.symbol,
                                            type: 'ERC20',
                                        }
                                        : undefined });
                                depositCmd.done();
                                putInStore({
                                    store: __outgoing.current,
                                    address: address,
                                    item: item,
                                });
                                putInStore({
                                    store: __transfers.current,
                                    address: address,
                                    item: item,
                                });
                                return [3 /*break*/, 14];
                            case 13:
                                e_3 = _e.sent();
                                console.error('fees: error', 4, e_3);
                                depositCmd.failed({ message: e_3.message || e_3.reason });
                                return [3 /*break*/, 14];
                            case 14: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
    }, [depositCmd.is.ready]);
    react_1.useEffect(function () {
        var active = __active.current;
        var address = __address.current;
        var chainId = __chainId.current;
        var swapDepositCmd = __swapDepositCmd.current;
        var safeSwapContractWeb3 = __safeSwapContractWeb3.current;
        if (swapDepositCmd.is.ready && !swapDepositCmd.is.running) {
            swapDepositCmd.start();
            (function runDepositCmd() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, from, to_2, value_2, desiredValue_1, publicSalt, privateSalt, secretHash_2, message, serviceRequestParams, request_2, total, gasPrice, sendValue, gas, _a, sendPayload_2, _b, txid, hex, e_4;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                _c.trys.push([0, 7, , 8]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId);
                                from = swapDepositCmd.from, to_2 = swapDepositCmd.to, value_2 = swapDepositCmd.value, desiredValue_1 = swapDepositCmd.desiredValue, publicSalt = swapDepositCmd.publicSalt, privateSalt = swapDepositCmd.privateSalt, secretHash_2 = swapDepositCmd.secretHash, message = swapDepositCmd.message;
                                if (!service)
                                    throw new Error('service not started');
                                if (!active)
                                    throw new Error('web3 not connected');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!safeSwapContractWeb3)
                                    throw new Error('safeSwap contract not found');
                                if (from !== address)
                                    throw new Error('from does not match address');
                                serviceRequestParams = {
                                    from: from,
                                    to: to_2,
                                    value: value_2,
                                    publicSalt: publicSalt,
                                    privateSalt: privateSalt,
                                    secretHash: secretHash_2,
                                    message: message,
                                    interchange: {
                                        value: desiredValue_1,
                                    },
                                };
                                if (__currency.current.symbol !== 'ETH') {
                                    serviceRequestParams.token = {
                                        address: __currency.current.address,
                                        decimals: __currency.current.decimals,
                                        symbol: __currency.current.symbol,
                                        type: 'ERC20',
                                    };
                                }
                                else if (__desiredCurrency.current.symbol !== 'ETH') {
                                    serviceRequestParams.interchange.token = {
                                        address: __desiredCurrency.current.address,
                                        decimals: __desiredCurrency.current.decimals,
                                        symbol: __desiredCurrency.current.symbol,
                                        type: 'ERC20',
                                    };
                                }
                                return [4 /*yield*/, service
                                        .getService(SERVICE.TRANSFER_REQUEST(network))
                                        .create(serviceRequestParams)];
                            case 1:
                                request_2 = _c.sent();
                                total = web3_utils_1.toBN(value_2).add(web3_utils_1.toBN(request_2.fees));
                                gasPrice = gasPriceMap.get(network);
                                sendValue = currency.symbol === 'ETH' ? total : request_2.fees;
                                _a = web3_utils_1.toBN;
                                return [4 /*yield*/, safeSwapContractWeb3.methods
                                        .deposit(to_2, currency.address, value_2, request_2.fees, desiredCurrency.address, desiredValue_1, request_2.swap.fees, secretHash_2)
                                        .estimateGas({ from: address, value: sendValue })];
                            case 2:
                                gas = _a.apply(void 0, [_c.sent()])
                                    .mul(web3_utils_1.toBN(11))
                                    .div(web3_utils_1.toBN(10))
                                    .toString();
                                sendPayload_2 = {
                                    from: from,
                                    gasPrice: gasPrice,
                                    gas: gas,
                                    value: sendValue,
                                };
                                if (!(connectCmd.connector !== useWeb3_2.Connectors.InAppWallet)) return [3 /*break*/, 4];
                                _b = sendPayload_2;
                                return [4 /*yield*/, __web3.current.eth.getTransactionCount(address, 'pending')];
                            case 3:
                                _b.nonce = _c.sent();
                                _c.label = 4;
                            case 4: return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    safeSwapContractWeb3.methods
                                        .deposit(to_2, currency.address, value_2, request_2.fees, desiredCurrency.address, desiredValue_1, request_2.swap.fees, secretHash_2)
                                        .send(sendPayload_2)
                                        .on('transactionHash', function (hash) { return resolve(hash); })
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        .on('error', function (err) { return reject(err); });
                                })];
                            case 5:
                                txid = _c.sent();
                                hex = safeSwapContractWeb3.methods
                                    .deposit(to_2, currency.address, value_2, request_2.fees, desiredCurrency.address, desiredValue_1, request_2.swap.fees, secretHash_2)
                                    .encodeABI();
                                return [4 /*yield*/, service.getService(SERVICE.FOLLOW(network)).create({
                                        txid: txid,
                                        hex: hex,
                                    })];
                            case 6:
                                _c.sent();
                                swapDepositCmd.done();
                                putInStore({
                                    store: __swaps.current,
                                    address: address,
                                    item: __assign(__assign({}, request_2), { collect: { broadcasted: -1, confirmed: -1, txid: '' }, deposit: { txid: txid, broadcasted: -1, confirmed: -1 }, swap: { txid: '', broadcasted: -1, confirmed: -1 }, expires: { at: request_2.expiresAt }, state: 'creating', retrieve: { broadcasted: -1, confirmed: -1, txid: '' }, message: message,
                                        txid: txid, salt: request_2.publicSalt, updatedAt: request_2.createdAt, token: currency.symbol !== 'ETH'
                                            ? {
                                                address: currency.address,
                                                decimals: currency.decimals,
                                                symbol: currency.symbol,
                                                type: 'ERC20',
                                            }
                                            : undefined, interchange: {
                                            value: desiredValue_1,
                                            token: {
                                                address: __desiredCurrency.current.address,
                                                decimals: __desiredCurrency.current.decimals,
                                                symbol: __desiredCurrency.current.symbol,
                                                type: 'ERC20',
                                            },
                                            fees: request_2.swap.fees,
                                        } }),
                                });
                                return [3 /*break*/, 8];
                            case 7:
                                e_4 = _c.sent();
                                console.error('fees: error swapDepositCmd', 4, e_4);
                                swapDepositCmd.failed({ message: e_4.message || e_4.reason });
                                return [3 /*break*/, 8];
                            case 8: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
    }, [swapDepositCmd.is.ready]);
    // on account.retrieve command
    react_1.useEffect(function () {
        var active = __active.current;
        var address = __address.current;
        var chainId = __chainId.current;
        var outgoing = __outgoing.current;
        var retrieveCmd = __retrieveCmd.current;
        var safeTransferContractWeb3 = __safeTransferContractWeb3.current;
        if (retrieveCmd.is.ready && !retrieveCmd.is.running) {
            retrieveCmd.start();
            (function runRetrieveCmd() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, transfer, from, to_3, fees_1, value_3, secretHash_3, token_1, gasPrice, gas, _a, _b, sendPayload_3, _c, txid, _d, hex, payload, e_5;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                _e.trys.push([0, 12, , 13]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId);
                                if (!service)
                                    throw new Error('service not started');
                                if (!active)
                                    throw new Error('web3 not connected');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!safeTransferContractWeb3)
                                    throw new Error('safeTransfer contract not found');
                                transfer = outgoing.map.get(retrieveCmd.id);
                                if (!transfer)
                                    throw new Error('transfer not found');
                                from = transfer.from, to_3 = transfer.to, fees_1 = transfer.fees, value_3 = transfer.value, secretHash_3 = transfer.secretHash, token_1 = transfer.token;
                                if (from !== address)
                                    throw new Error('from address does not match connected address');
                                gasPrice = gasPriceMap.get(network);
                                _a = web3_utils_1.toBN;
                                if (!(token_1.symbol && token_1.symbol !== 'ETH')) return [3 /*break*/, 2];
                                return [4 /*yield*/, safeTransferContractWeb3.methods
                                        .retrieveERC20(token_1.address, token_1.symbol, to_3, value_3, fees_1, secretHash_3)
                                        .estimateGas({ from: address })];
                            case 1:
                                _b = _e.sent();
                                return [3 /*break*/, 4];
                            case 2: return [4 /*yield*/, safeTransferContractWeb3.methods
                                    .retrieve(to_3, value_3, fees_1, secretHash_3)
                                    .estimateGas({ from: address })];
                            case 3:
                                _b = _e.sent();
                                _e.label = 4;
                            case 4:
                                gas = _a.apply(void 0, [_b])
                                    .mul(web3_utils_1.toBN(11))
                                    .div(web3_utils_1.toBN(10))
                                    .toString();
                                sendPayload_3 = {
                                    from: from,
                                    gasPrice: gasPrice,
                                    gas: gas,
                                };
                                if (!(connectCmd.connector !== useWeb3_2.Connectors.InAppWallet)) return [3 /*break*/, 6];
                                _c = sendPayload_3;
                                return [4 /*yield*/, __web3.current.eth.getTransactionCount(address, 'pending')];
                            case 5:
                                _c.nonce = _e.sent();
                                _e.label = 6;
                            case 6:
                                if (!(token_1.symbol && token_1.symbol !== 'ETH')) return [3 /*break*/, 8];
                                return [4 /*yield*/, new Promise(function (resolve, reject) {
                                        safeTransferContractWeb3.methods
                                            .retrieveERC20(token_1.address, token_1.symbol, to_3, value_3, fees_1, secretHash_3)
                                            .send(sendPayload_3)
                                            .on('transactionHash', function (hash) { return resolve(hash); })
                                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            .on('error', function (err) { return reject(err); });
                                    })];
                            case 7:
                                _d = _e.sent();
                                return [3 /*break*/, 10];
                            case 8: return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    safeTransferContractWeb3.methods
                                        .retrieve(to_3, value_3, fees_1, secretHash_3)
                                        .send(sendPayload_3)
                                        .on('transactionHash', function (hash) { return resolve(hash); })
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        .on('error', function (err) { return reject(err); });
                                })];
                            case 9:
                                _d = _e.sent();
                                _e.label = 10;
                            case 10:
                                txid = _d;
                                hex = token_1.symbol && token_1.symbol !== 'ETH'
                                    ? safeTransferContractWeb3.methods
                                        .retrieveERC20(token_1.address, token_1.symbol, to_3, value_3, fees_1, secretHash_3)
                                        .encodeABI()
                                    : safeTransferContractWeb3.methods
                                        .retrieve(to_3, value_3, fees_1, secretHash_3)
                                        .encodeABI();
                                return [4 /*yield*/, service.getService(SERVICE.FOLLOW(network)).create({
                                        txid: txid,
                                        hex: hex,
                                    })];
                            case 11:
                                _e.sent();
                                payload = {
                                    id: transfer.id,
                                    state: 'retrieving',
                                };
                                if (txid)
                                    payload.txid = txid;
                                __outgoing.current.update(address, payload);
                                __transfers.current.update(address, payload);
                                retrieveCmd.done();
                                return [3 /*break*/, 13];
                            case 12:
                                e_5 = _e.sent();
                                console.error('fees: error undo', 4, e_5);
                                retrieveCmd.failed({ message: e_5.message || e_5.reason });
                                return [3 /*break*/, 13];
                            case 13: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
    }, [retrieveCmd.is.ready]);
    // on account.swapRetrieve command
    react_1.useEffect(function () {
        var active = __active.current;
        var address = __address.current;
        var chainId = __chainId.current;
        var swaps = __swaps.current;
        var swapRetrieveCmd = __swapRetrieveCmd.current;
        var safeSwapContractWeb3 = __safeSwapContractWeb3.current;
        if (swapRetrieveCmd.is.ready && !swapRetrieveCmd.is.running) {
            swapRetrieveCmd.start();
            (function runSwapRetrieveCmd() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, transfer, from, to_4, fees_2, value_4, secretHash_4, token_2, swap_1, gasPrice, gas, _a, sendPayload_4, _b, txid, hex, payload, e_6;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                _c.trys.push([0, 7, , 8]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId);
                                if (!service)
                                    throw new Error('service not started');
                                if (!active)
                                    throw new Error('web3 not connected');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!safeSwapContractWeb3)
                                    throw new Error('safeSwap contract not found');
                                transfer = swaps.map.get(swapRetrieveCmd.id);
                                if (!transfer)
                                    throw new Error('transfer not found');
                                from = transfer.from, to_4 = transfer.to, fees_2 = transfer.fees, value_4 = transfer.value, secretHash_4 = transfer.secretHash, token_2 = transfer.token, swap_1 = transfer.swap;
                                if (from !== address)
                                    throw new Error('from address does not match connected address');
                                gasPrice = gasPriceMap.get(network);
                                _a = web3_utils_1.toBN;
                                return [4 /*yield*/, safeSwapContractWeb3.methods
                                        .retrieve(to_4, token_2.address || '0x0000000000000000000000000000000000000000', value_4, fees_2, swap_1.token.address || '0x0000000000000000000000000000000000000000', swap_1.value, swap_1.fees, secretHash_4)
                                        .estimateGas({ from: address })];
                            case 1:
                                gas = _a.apply(void 0, [_c.sent()])
                                    .mul(web3_utils_1.toBN(11))
                                    .div(web3_utils_1.toBN(10))
                                    .toString();
                                sendPayload_4 = {
                                    from: from,
                                    gasPrice: gasPrice,
                                    gas: gas,
                                };
                                if (!(connectCmd.connector !== useWeb3_2.Connectors.InAppWallet)) return [3 /*break*/, 3];
                                _b = sendPayload_4;
                                return [4 /*yield*/, __web3.current.eth.getTransactionCount(address, 'pending')];
                            case 2:
                                _b.nonce = _c.sent();
                                _c.label = 3;
                            case 3: return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    safeSwapContractWeb3.methods
                                        .retrieve(to_4, token_2.address || '0x0000000000000000000000000000000000000000', value_4, fees_2, swap_1.token.address || '0x0000000000000000000000000000000000000000', swap_1.value, swap_1.fees, secretHash_4)
                                        .send(sendPayload_4)
                                        .on('transactionHash', function (hash) { return resolve(hash); })
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        .on('error', function (err) { return reject(err); });
                                })];
                            case 4:
                                txid = _c.sent();
                                return [4 /*yield*/, safeSwapContractWeb3.methods
                                        .retrieve(to_4, token_2.address || '0x0000000000000000000000000000000000000000', value_4, fees_2, swap_1.token.address || '0x0000000000000000000000000000000000000000', swap_1.value, swap_1.fees, secretHash_4)
                                        .encodeABI()];
                            case 5:
                                hex = _c.sent();
                                return [4 /*yield*/, service.getService(SERVICE.FOLLOW(network)).create({
                                        txid: txid,
                                        hex: hex,
                                    })];
                            case 6:
                                _c.sent();
                                payload = {
                                    id: transfer.id,
                                    state: 'retrieving',
                                };
                                if (txid)
                                    payload.txid = txid;
                                __swaps.current.update(address, payload);
                                swapRetrieveCmd.done();
                                return [3 /*break*/, 8];
                            case 7:
                                e_6 = _c.sent();
                                console.error('fees: error undo swap', 4, e_6);
                                swapRetrieveCmd.failed({ message: e_6.message || e_6.reason });
                                return [3 /*break*/, 8];
                            case 8: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
    }, [swapRetrieveCmd.is.ready]);
    // on account.collect command
    react_1.useEffect(function () {
        var chainId = __chainId.current;
        var collectCmd = __collectCmd.current;
        var safeTransferContractWeb3 = __safeTransferContractWeb3.current;
        var address = __address.current;
        if (collectCmd.is.ready && !collectCmd.is.running) {
            collectCmd.start();
            (function runCollectCmd() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, id, key, e_7;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId < 1 ? 1 : chainId);
                                id = collectCmd.id, key = collectCmd.key;
                                if (!service)
                                    throw new Error('service not started');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!safeTransferContractWeb3)
                                    throw new Error('safeTransfer contract not found');
                                return [4 /*yield*/, service.getService(SERVICE.COLLECT(network)).create({ id: id, key: key })];
                            case 1:
                                _a.sent();
                                __incoming.current.update(address, { id: id, state: 'collecting' });
                                __transfers.current.update(address, { id: id, state: 'collecting' });
                                collectCmd.done();
                                return [3 /*break*/, 3];
                            case 2:
                                e_7 = _a.sent();
                                collectCmd.failed({ message: e_7.name || e_7.message || e_7.reason });
                                return [3 /*break*/, 3];
                            case 3: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
    }, [collectCmd.is.ready]);
    // on account.swap command
    react_1.useEffect(function () {
        var chainId = __chainId.current;
        var swapCmd = __swapCmd.current;
        var safeSwapContractWeb3 = __safeSwapContractWeb3.current;
        var address = __address.current;
        if (swapCmd.is.ready && !swapCmd.is.running) {
            swapCmd.start();
            (function runswapCmdCmd() {
                return __awaiter(this, void 0, void 0, function () {
                    var service, network, id, key, request_3, transfer, from_1, to, fees_3, value_5, secretHash_5, token_3, swap_2, gasPrice, ethValue, gas, _a, sendPayload_5, _b, txid, hex, payload, e_8;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                _c.trys.push([0, 8, , 9]);
                                service = safe_transfer_lib_lite_1.default.getInstance();
                                network = getChainName(chainId < 1 ? 1 : chainId);
                                id = swapCmd.id, key = swapCmd.key;
                                if (!service)
                                    throw new Error('service not started');
                                if (!network)
                                    throw new Error('chain is not supported');
                                if (!safeSwapContractWeb3)
                                    throw new Error('safeTransfer contract not found');
                                return [4 /*yield*/, service
                                        .getService(SERVICE.SWAP(network))
                                        .create({ id: id, key: key })];
                            case 1:
                                request_3 = _c.sent();
                                transfer = swaps.map.get(swapCmd.id);
                                if (!transfer)
                                    throw new Error('transfer not found');
                                from_1 = transfer.from, to = transfer.to, fees_3 = transfer.fees, value_5 = transfer.value, secretHash_5 = transfer.secretHash, token_3 = transfer.token, swap_2 = transfer.swap;
                                gasPrice = gasPriceMap.get(network);
                                ethValue = !swap_2.token.symbol || swap_2.token.symbol === 'ETH'
                                    ? web3_utils_1.toBN(swap_2.value).add(web3_utils_1.toBN(swap_2.fees)).toString()
                                    : swap_2.fees;
                                _a = web3_utils_1.toBN;
                                return [4 /*yield*/, safeSwapContractWeb3.methods
                                        .swap(from_1, token_3.address || '0x0000000000000000000000000000000000000000', value_5, fees_3, swap_2.token.address ||
                                        '0x0000000000000000000000000000000000000000', swap_2.value, swap_2.fees, secretHash_5, request_3.secret)
                                        .estimateGas({ from: to, value: ethValue })];
                            case 2:
                                gas = _a.apply(void 0, [_c.sent()])
                                    .mul(web3_utils_1.toBN(11))
                                    .div(web3_utils_1.toBN(10))
                                    .toString();
                                sendPayload_5 = {
                                    from: to,
                                    gasPrice: gasPrice,
                                    gas: gas,
                                    value: ethValue,
                                };
                                if (!(connectCmd.connector !== useWeb3_2.Connectors.InAppWallet)) return [3 /*break*/, 4];
                                _b = sendPayload_5;
                                return [4 /*yield*/, __web3.current.eth.getTransactionCount(address, 'pending')];
                            case 3:
                                _b.nonce = _c.sent();
                                _c.label = 4;
                            case 4: return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    safeSwapContractWeb3.methods
                                        .swap(from_1, token_3.address || '0x0000000000000000000000000000000000000000', value_5, fees_3, swap_2.token.address ||
                                        '0x0000000000000000000000000000000000000000', swap_2.value, swap_2.fees, secretHash_5, request_3.secret)
                                        .send(sendPayload_5)
                                        .on('transactionHash', function (hash) { return resolve(hash); })
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        .on('error', function (err) { return reject(err); });
                                })];
                            case 5:
                                txid = _c.sent();
                                return [4 /*yield*/, safeSwapContractWeb3.methods.swap(from_1, token_3.address || '0x0000000000000000000000000000000000000000', value_5, fees_3, swap_2.token.address || '0x0000000000000000000000000000000000000000', swap_2.value, swap_2.fees, secretHash_5, request_3.secret).encodeABI()];
                            case 6:
                                hex = _c.sent();
                                return [4 /*yield*/, service.getService(SERVICE.FOLLOW(network)).create({
                                        txid: txid,
                                        hex: hex
                                    })];
                            case 7:
                                _c.sent();
                                payload = {
                                    id: transfer.id,
                                    state: 'swapping',
                                };
                                if (txid)
                                    payload.txid = txid;
                                __swaps.current.update(address, payload);
                                swapCmd.done();
                                return [3 /*break*/, 9];
                            case 8:
                                e_8 = _c.sent();
                                console.log('swapcmd err', e_8);
                                swapCmd.failed({ message: e_8.name || e_8.message || e_8.reason });
                                return [3 /*break*/, 9];
                            case 9: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
    }, [swapCmd.is.ready]);
    var getDeviceInfo = function () { return __awaiter(void 0, void 0, void 0, function () {
        function handleEthereum() {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var ethereum, loggedIn, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            ethereum = window.ethereum;
                            loggedIn = false;
                            if (!(ethereum && ethereum.isMetaMask)) return [3 /*break*/, 4];
                            _d.label = 1;
                        case 1:
                            _d.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, ((_a = ethereum) === null || _a === void 0 ? void 0 : _a.request({ method: 'eth_accounts' }))];
                        case 2:
                            loggedIn = !!((_b = (_d.sent())) === null || _b === void 0 ? void 0 : _b.length);
                            return [3 /*break*/, 4];
                        case 3:
                            _c = _d.sent();
                            loggedIn = false;
                            return [3 /*break*/, 4];
                        case 4:
                            __setDeviceInfo.current({
                                isMobile: parser.getResult().device.type === 'mobile',
                                haveMetaMask: !!(ethereum && ethereum.isMetaMask),
                                ethereumProvider: !!ethereum,
                                loggedIn: loggedIn,
                            });
                            return [2 /*return*/];
                    }
                });
            });
        }
        var parser;
        return __generator(this, function (_a) {
            parser = new ua_parser_js_1.UAParser();
            if (window.ethereum)
                handleEthereum();
            else {
                __setDeviceInfo.current({
                    isMobile: parser.getResult().device.type === 'mobile',
                    haveMetaMask: false,
                    ethereumProvider: false,
                    loggedIn: false,
                });
                window.addEventListener('ethereum#initialized', handleEthereum, {
                    once: true,
                });
                setTimeout(handleEthereum, 3000);
            }
            return [2 /*return*/];
        });
    }); };
    // init
    react_1.useEffect(function () {
        var _a, _b;
        var authDetails = {
            key: (_a = process.env.REACT_APP_AUTH_KEY) !== null && _a !== void 0 ? _a : '',
            secret: (_b = process.env.REACT_APP_AUTH_SECRET) !== null && _b !== void 0 ? _b : '',
        };
        getDeviceInfo();
        safe_transfer_lib_lite_1.default.createInstance({
            key: authDetails.key,
            secret: authDetails.secret,
        }, function (message, payload) {
            var setCanGetRewards = __setCanGetRewards.current;
            if (message === 'authorized') {
                setCanGetRewards(!!(payload === null || payload === void 0 ? void 0 : payload.rewards));
                setStatus(true);
            }
            if (message === 'disconnected') {
                setCanGetRewards(!!(payload === null || payload === void 0 ? void 0 : payload.rewards));
                setStatus(false);
            }
        });
        return function () {
            safe_transfer_lib_lite_1.default.createInstance({ key: '', secret: '' });
        };
    }, []);
    // on api server authorized event
    react_1.useEffect(function () {
        var service = safe_transfer_lib_lite_1.default.getInstance();
        if (status && service) {
            var networkService = service.getService(SERVICE.NETWORKS);
            var ratesService_1 = service.getService(SERVICE.RATES);
            var tokenRatesService_1 = service.getService(SERVICE.TOKEN_RATES);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var setNetworkDetails_1 = function (network) {
                __setGasPrice.current(network.netId, network.gasPrice);
                if (network.netId === 'main')
                    setHeightMain(network.height);
                else if (network.netId === 'rinkeby')
                    setHeightRinkeby(network.height);
            };
            networkService
                .find({ query: { watch: 'replace' } })
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .then(function (networks) { return __awaiter(void 0, void 0, void 0, function () {
                var tokensRates, resRateService, _i, _a, network, erc20Service, rate, tokens, eth, kiroToken;
                var _b, _c, _d, _e;
                return __generator(this, function (_f) {
                    switch (_f.label) {
                        case 0:
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            tokenRatesService_1.on('patched', function (rates) {
                                for (var _i = 0, _a = networks.data; _i < _a.length; _i++) {
                                    var network = _a[_i];
                                    var token = __ERC20TokenList
                                        .current(network.netId)
                                        .find(function (token) { return token.symbol === rates.symbol; });
                                    __setErc20TokenRate.current(network.netId, token === null || token === void 0 ? void 0 : token.address, rates.usd);
                                }
                            });
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            ratesService_1.on('updated', function (rates) {
                                for (var _i = 0, _a = networks.data; _i < _a.length; _i++) {
                                    var network = _a[_i];
                                    var token = __ERC20TokenList
                                        .current(network.netId)
                                        .find(function (token) { return token.symbol === rates.symbol; });
                                    __setErc20TokenRate.current(network.netId, token === null || token === void 0 ? void 0 : token.address, rates.value);
                                }
                                __setRate.current(rates.value);
                            });
                            return [4 /*yield*/, tokenRatesService_1.find({
                                    query: { watch: 'replace' },
                                })
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            ];
                        case 1:
                            tokensRates = (_f.sent()).data;
                            return [4 /*yield*/, ratesService_1.find({
                                    query: { source: 'coingecko.com', watch: 'replace' },
                                })];
                        case 2:
                            resRateService = _f.sent();
                            _i = 0, _a = networks.data;
                            _f.label = 3;
                        case 3:
                            if (!(_i < _a.length)) return [3 /*break*/, 6];
                            network = _a[_i];
                            setNetworkDetails_1(network);
                            if ((_b = network === null || network === void 0 ? void 0 : network.contracts) === null || _b === void 0 ? void 0 : _b.safeTransfer) {
                                __setSafeTransferContract.current(network.netId, network.contracts.safeTransfer);
                            }
                            if ((_c = network === null || network === void 0 ? void 0 : network.contracts) === null || _c === void 0 ? void 0 : _c.safeSwap) {
                                __setSafeSwapContract.current(network.netId, network.contracts.safeSwap);
                            }
                            if ((_d = network === null || network === void 0 ? void 0 : network.contracts) === null || _d === void 0 ? void 0 : _d.staking) {
                                __setStakingContract.current(network.netId, network.contracts.staking);
                            }
                            if ((_e = network === null || network === void 0 ? void 0 : network.contracts) === null || _e === void 0 ? void 0 : _e.kiroToken) {
                                __setKiroTokenContract.current(network.netId, network.contracts.kiroToken);
                            }
                            erc20Service = service.getService(SERVICE.ERC20(network.netId));
                            rate = 0;
                            if (resRateService.data.length === 1) {
                                rate = resRateService.data[0].value;
                                __setRate.current(rate);
                            }
                            return [4 /*yield*/, erc20Service.find({})];
                        case 4:
                            tokens = (_f.sent())
                                .data.map(function (token) {
                                var _a;
                                return ({
                                    address: token.address,
                                    symbol: token.symbol,
                                    decimals: token.decimals,
                                    name: token.name,
                                    balance: '',
                                    rate: (_a = tokensRates.find(function (_a) {
                                        var symbol = _a.symbol;
                                        return symbol === token.symbol;
                                    })) === null || _a === void 0 ? void 0 : _a.usd,
                                });
                            });
                            eth = {
                                address: '0x0000000000000000000000000000000000000000',
                                symbol: 'ETH',
                                decimals: 18,
                                name: 'Ethereum',
                                balance: '',
                                rate: rate,
                            };
                            kiroToken = tokens.find(function (token) { return token.symbol === 'KIRO'; });
                            if (kiroToken && network.netId === getChainName(__chainId.current)) {
                                setCurrency(eth);
                                setDesiredCurrency(kiroToken);
                            }
                            tokens.unshift(eth);
                            __setERC20TokenContract.current(network.netId, tokens);
                            _f.label = 5;
                        case 5:
                            _i++;
                            return [3 /*break*/, 3];
                        case 6: return [2 /*return*/];
                    }
                });
            }); });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            networkService.on('patched', function (network) {
                var _a, _b;
                setNetworkDetails_1(network);
                if ((_a = network === null || network === void 0 ? void 0 : network.contracts) === null || _a === void 0 ? void 0 : _a.safeTransfer) {
                    __setSafeTransferContract.current(network.netId, network.contracts.safeTransfer);
                }
                if ((_b = network === null || network === void 0 ? void 0 : network.contracts) === null || _b === void 0 ? void 0 : _b.safeSwap) {
                    __setSafeSwapContract.current(network.netId, network.contracts.safeSwap);
                }
            });
        }
    }, [status]);
    react_1.useEffect(function () {
        var web3 = __web3.current;
        var chainId = __chainId.current;
        if (!web3)
            return;
        var setSafeTransferAsync = function () { return __awaiter(void 0, void 0, void 0, function () {
            var gasPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, web3.eth.getGasPrice()];
                    case 1:
                        gasPrice = _a.sent();
                        if (web3 && chainId && safeTransferContract) {
                            setSafeTransferContractWeb3(new web3.eth.Contract(
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            safeTransfer_json_1.default, safeTransferContract.address, { gasPrice: gasPrice, gas: 60000 }));
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        setSafeTransferAsync();
    }, [safeTransferContract, connectCmd.is.done]);
    react_1.useEffect(function () {
        var web3 = __web3.current;
        var chainId = __chainId.current;
        if (!web3)
            return;
        var setSafeSwapAsync = function () { return __awaiter(void 0, void 0, void 0, function () {
            var gasPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, web3.eth.getGasPrice()];
                    case 1:
                        gasPrice = _a.sent();
                        if (web3 && chainId && safeSwapContract) {
                            setSafeSwapContractWeb3(new web3.eth.Contract(
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            safeSwap_json_1.default, safeSwapContract.address, { gasPrice: gasPrice, gas: 120000 }));
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        setSafeSwapAsync();
    }, [safeSwapContract, connectCmd.is.done]);
    // on web3 connect command
    react_1.useEffect(function () {
        var web3Connect = __web3Connect.current;
        var connectCmd = __connectCmd.current;
        if (connectCmd.is.ready && !connectCmd.is.running) {
            connectCmd.start();
            web3Connect(connectCmd.connector)
                .then(function () {
                connectCmd.done();
            })
                .catch(function (e) {
                connectCmd.failed({ message: e ? JSON.stringify(e) : 'failed' });
            });
        }
    }, [connectCmd.is.ready]);
    // on web3 disconnect command
    react_1.useEffect(function () {
        var web3Disconnect = __web3Disconnect.current;
        var disconnectCmd = __disconnectCmd.current;
        var connectCmd = __connectCmd.current;
        if (disconnectCmd.is.ready && !disconnectCmd.is.running) {
            disconnectCmd.start();
            web3Disconnect();
            disconnectCmd.done();
            connectCmd.prepare(undefined);
        }
    }, [disconnectCmd.is.ready]);
    react_1.useEffect(function () {
        var setBlock = __setBlock.current;
        setBlock(0);
    }, [web3ChainId]);
    react_1.useEffect(function () {
        var transfers = __transfers.current;
        var incoming = __incoming.current;
        var outgoing = __outgoing.current;
        var history = __history.current;
        var swaps = __swaps.current;
        var setActive = __setActive.current;
        var setAddress = __setAddress.current;
        var setChainId = __setChainId.current;
        var setBalance = __setBalance.current;
        var setTokenBalance = __setTokenBalance.current;
        var setStakingBalance = __setStakingBalance.current;
        var clearERC20TokenBalances = __clearERC20TokenBalances.current;
        setActive(web3Active);
        setAddress(web3Address || '');
        setChainId(web3ChainId || -1);
        setBalance('');
        setTokenBalance('');
        setStakingBalance('');
        clearERC20TokenBalances();
        transfers.clear();
        outgoing.clear();
        incoming.clear();
        history.clear();
        swaps.clear();
    }, [web3Address, web3ChainId, web3Active]);
    react_1.useEffect(function () {
        var setBlock = __setBlock.current;
        if (chainId <= 1) {
            setBlock(heightMain);
        }
        else if (chainId === 4) {
            setBlock(heightRinkeby);
        }
        else {
            setBlock(0);
        }
    }, [status, chainId, heightMain, heightRinkeby]);
    react_1.useEffect(function () {
        var _a, _b, _c, _d, _e, _f;
        var service = safe_transfer_lib_lite_1.default.getInstance();
        if (address && status) {
            var network_1 = getChainName(chainId < 1 ? 1 : chainId);
            if (network_1) {
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.BALANCE(network_1)).find({
                    query: {
                        address: address,
                        erc20: (_b = (_a = __ERC20TokenList
                            .current(network_1)) === null || _a === void 0 ? void 0 : _a.filter(function (item) {
                            return item.address !==
                                '0x0000000000000000000000000000000000000000';
                        })) === null || _b === void 0 ? void 0 : _b.map(function (item) { return item.address; }).join(';'),
                    },
                }).then(function (response) {
                    var balance = response.data[0];
                    __setBalance.current((balance === null || balance === void 0 ? void 0 : balance.balance) || '');
                    __setStakingBalance.current((balance === null || balance === void 0 ? void 0 : balance.stakingBalance) || '');
                    __setERC20TokenBalance.current(network_1, '0x0000000000000000000000000000000000000000', (balance === null || balance === void 0 ? void 0 : balance.balance) || '');
                    __setMaxRewards.current((balance === null || balance === void 0 ? void 0 : balance.maxRewards) || 10);
                    if (__currency.current.symbol === 'ETH') {
                        __setTokenBalance.current((balance === null || balance === void 0 ? void 0 : balance.kiroBalance) || '');
                    }
                    if (__currency.current.balance === '' &&
                        __currency.current.symbol === 'ETH') {
                        __setCurrencyBalance.current((balance === null || balance === void 0 ? void 0 : balance.balance) || '');
                    }
                    for (var _i = 0, _a = Object.entries((balance === null || balance === void 0 ? void 0 : balance.erc20) || {}); _i < _a.length; _i++) {
                        var entry = _a[_i];
                        __setERC20TokenBalance.current(network_1, entry[0], entry[1]);
                        if (__currency.current.address === entry[0]) {
                            __setTokenBalance.current(entry[1]);
                        }
                    }
                }).catch(function (reason) { return console.log("error", { reason: reason }); });
                if (__currency.current.symbol !== 'ETH' &&
                    ((_c = __safeTransferContract.current) === null || _c === void 0 ? void 0 : _c.address) &&
                    ((_d = __safeSwapContract.current) === null || _d === void 0 ? void 0 : _d.address) &&
                    __erc20TokenContractWeb3.current.currentProvider) {
                    var contractAddress = formType === 'swap'
                        ? (_e = __safeSwapContract.current) === null || _e === void 0 ? void 0 : _e.address
                        : (_f = __safeTransferContract.current) === null || _f === void 0 ? void 0 : _f.address;
                    __erc20TokenContractWeb3.current.methods
                        .allowance(address, contractAddress)
                        .call()
                        .then(function (allowance) { return __setAllowance.current(allowance); });
                }
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.REWARDS(network_1)).find({
                    query: { address: address },
                }).then(function (response) {
                    var rewardParams = response.data[0];
                    if (rewardParams && rewardParams.address === address) {
                        __setRewardsParams.current(rewardParams.factor, rewardParams.left);
                    }
                    else
                        __setRewardsParams.current(1, 10);
                }).catch(function (reason) {
                    console.warn("error: " + JSON.stringify(reason));
                });
            }
            else {
                __setBalance.current('');
                __setTokenBalance.current('');
                __setAllowance.current('');
                __setStakingBalance.current('');
                __setRewardsParams.current(1, 10);
                __setMaxRewards.current(10);
                __clearERC20TokenBalances.current();
            }
        }
        else {
            __setBalance.current('');
            __setTokenBalance.current('');
            __setAllowance.current('');
            __setStakingBalance.current('');
            __setRewardsParams.current(1, 10);
            __setMaxRewards.current(10);
            __clearERC20TokenBalances.current();
        }
    }, [status, chainId, address, heightMain, heightRinkeby]);
    react_1.useEffect(function () {
        if (swapperAddress && (desiredCurrency === null || desiredCurrency === void 0 ? void 0 : desiredCurrency.symbol)) {
            ;
            (function setBalance() {
                return __awaiter(this, void 0, void 0, function () {
                    var balance, networkName, validDesiredCurrency, desiredCurrencyContract, balance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(desiredCurrency.symbol === 'ETH')) return [3 /*break*/, 2];
                                return [4 /*yield*/, web3.eth.getBalance(swapperAddress)];
                            case 1:
                                balance = _a.sent();
                                setSwapperBalance(balance);
                                return [3 /*break*/, 4];
                            case 2:
                                networkName = getChainName(chainId);
                                validDesiredCurrency = !!ERC20TokenList(networkName).find(function (token) {
                                    return token.address === desiredCurrency.address &&
                                        token.symbol === desiredCurrency.symbol;
                                });
                                if (!validDesiredCurrency) return [3 /*break*/, 4];
                                desiredCurrencyContract = new web3.eth.Contract(
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                erc20_json_1.default, desiredCurrency.address);
                                return [4 /*yield*/, desiredCurrencyContract.methods
                                        .balanceOf(swapperAddress)
                                        .call()];
                            case 3:
                                balance = _a.sent();
                                setSwapperBalance(balance);
                                _a.label = 4;
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            })();
        }
        else
            setSwapperBalance('');
    }, [
        desiredCurrency.symbol,
        desiredCurrency.address,
        swapperAddress,
        ERC20TokenList,
        chainId,
    ]);
    react_1.useEffect(function () {
        var transfers = __transfers.current;
        var incoming = __incoming.current;
        var outgoing = __outgoing.current;
        var history = __history.current;
        var swaps = __swaps.current;
        var prevAddress = __prevAddress.current;
        var prevChainId = __prevChainId.current;
        var prevBlock = __prevBlock.current;
        var prevStatus = __prevStatus.current;
        var setCurrency = __setCurrency.current;
        var setDesiredCurrency = __setDesiredCurrency.current;
        if (!block) {
            transfers.clear();
            incoming.clear();
            outgoing.clear();
            history.clear();
            swaps.clear();
        }
        if (status && address && block) {
            var historyItems = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], removeFromStore({
                address: address,
                store: incoming,
                filter: function (item) {
                    return item.confirmedBlock > 0 &&
                        item.confirmedBlock <= block - MAX_CONFIRMS &&
                        (item.state === 'collected' ||
                            item.state === 'retrieved' ||
                            item.state === 'swapped');
                },
            })), removeFromStore({
                address: address,
                store: outgoing,
                filter: function (item) {
                    return item.confirmedBlock > 0 &&
                        item.confirmedBlock <= block - MAX_CONFIRMS &&
                        (item.state === 'collected' ||
                            item.state === 'retrieved' ||
                            item.state === 'swapped');
                },
            })), removeFromStore({
                address: address,
                store: transfers,
                filter: function (item) {
                    return item.confirmedBlock > 0 &&
                        item.confirmedBlock <= block - MAX_CONFIRMS &&
                        (item.state === 'collected' ||
                            item.state === 'retrieved' ||
                            item.state === 'swapped');
                },
            })), removeFromStore({
                address: address,
                store: swaps,
                filter: function (item) {
                    return item.confirmedBlock > 0 &&
                        item.confirmedBlock <= block - MAX_CONFIRMS &&
                        (item.state === 'collected' ||
                            item.state === 'retrieved' ||
                            item.state === 'swapped');
                },
            }));
            for (var _i = 0, historyItems_1 = historyItems; _i < historyItems_1.length; _i++) {
                var historyItem = historyItems_1[_i];
                moveToStore({ store: history, address: address, item: historyItem });
            }
        }
        if (status && address && prevChainId !== chainId) {
            setCurrency({
                address: '0x0000000000000000000000000000000000000000',
                symbol: 'ETH',
                decimals: 18,
                name: 'Ethereum',
                balance: '',
            });
            var getKiroAddress = function () {
                var networkName = getChainName(chainId);
                if (networkName === 'main')
                    return '0xb1191f691a355b43542bea9b8847bc73e7abb137';
                else if (networkName === 'rinkeby')
                    return '0xB678E95F83aF08E7598EC21533F7585E83272799';
                else
                    return '0x0000000000000000000000000000000000000000';
            };
            setDesiredCurrency({
                address: getKiroAddress(),
                symbol: 'KIRO',
                decimals: 18,
                name: 'Kiro Token',
                balance: '',
            });
        }
        if (status &&
            address &&
            block &&
            (!prevBlock ||
                address !== prevAddress ||
                prevChainId !== chainId ||
                !prevStatus)) {
            transfers.clear();
            incoming.clear();
            outgoing.clear();
            history.clear();
            swaps.clear();
            var network = getChainName(chainId < 1 ? 1 : chainId);
            var service = safe_transfer_lib_lite_1.default.getInstance();
            if (network && service) {
                transfers.fetch.run(40);
                incoming.fetch.run(40);
                outgoing.fetch.run(40);
                history.fetch.run(40);
                swaps.fetch.run(40);
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).removeAllListeners('created');
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).removeAllListeners('patched');
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).removeAllListeners('updated');
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).removeAllListeners('removed');
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).on('created', function (item) {
                    var _a, _b;
                    if (!((_a = item.interchange) === null || _a === void 0 ? void 0 : _a.value))
                        putInStore({ store: __transfers.current, address: address, item: item });
                    else if ((_b = item.interchange) === null || _b === void 0 ? void 0 : _b.value)
                        putInStore({ store: __swaps.current, address: address, item: item });
                    if (item.from === address)
                        putInStore({ store: __outgoing.current, address: address, item: item });
                    else if (item.to === address)
                        putInStore({ store: __incoming.current, address: address, item: item });
                });
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).on('patched', function (item) {
                    var _a, _b;
                    if ((item.collect.confirmed > 0 &&
                        item.collect.confirmed <= block - MAX_CONFIRMS) ||
                        (item.retrieve.confirmed > 0 &&
                            item.retrieve.confirmed <= block - MAX_CONFIRMS)) {
                        putInStore({ store: __history.current, address: address, item: item });
                    }
                    if ((item.collect.confirmed > 0 &&
                        item.collect.confirmed <= block - MAX_CONFIRMS) ||
                        (item.retrieve.confirmed > 0 &&
                            item.retrieve.confirmed <= block - MAX_CONFIRMS) ||
                        (item.swap &&
                            item.swap.confirmed > 0 &&
                            item.swap.confirmed <= block - MAX_CONFIRMS)) {
                        deleteFromStore({
                            store: !((_a = item.interchange) === null || _a === void 0 ? void 0 : _a.value)
                                ? __transfers.current
                                : __swaps.current,
                            address: address,
                            id: item.id,
                        });
                    }
                    else {
                        putInStore({
                            store: !((_b = item.interchange) === null || _b === void 0 ? void 0 : _b.value)
                                ? __transfers.current
                                : __swaps.current,
                            address: address,
                            item: item,
                        });
                    }
                    if ((item.collect.confirmed > 0 &&
                        item.collect.confirmed <= block - MAX_CONFIRMS) ||
                        (item.retrieve.confirmed > 0 &&
                            item.retrieve.confirmed <= block - MAX_CONFIRMS) ||
                        (item.swap &&
                            item.swap.confirmed > 0 &&
                            item.swap.confirmed <= block - MAX_CONFIRMS)) {
                        deleteFromStore({
                            store: item.from === address
                                ? __outgoing.current
                                : __incoming.current,
                            address: address,
                            id: item.id,
                        });
                    }
                    else {
                        putInStore({
                            store: item.from === address
                                ? __outgoing.current
                                : __incoming.current,
                            address: address,
                            item: item,
                        });
                    }
                });
                service === null || service === void 0 ? void 0 : service.getService(SERVICE.TRANSFERS(network)).on('removed', function (item) {
                    deleteFromStore({
                        store: __transfers.current,
                        address: address,
                        id: item.id,
                    });
                    deleteFromStore({ store: __outgoing.current, address: address, id: item.id });
                    deleteFromStore({ store: __incoming.current, address: address, id: item.id });
                    deleteFromStore({ store: __swaps.current, address: address, id: item.id });
                    deleteFromStore({ store: __history.current, address: address, id: item.id });
                });
            }
        }
    }, [status, address, chainId, block]);
    // on transfers.fetch done
    /*
    useEffect(() => {
      const _history = __history.current
      if (history.fetched > 0 && history.fetched < 60) _history.fetch.run(40)
    }, [history.fetched])
    */
    // on incoming.fetch done
    react_1.useEffect(function () {
        var _incoming = __incoming.current;
        if (incoming.fetched > 0)
            _incoming.fetch.run(40);
    }, [incoming.fetched]);
    // on outgoing.fetch done
    react_1.useEffect(function () {
        var _outgoing = __outgoing.current;
        if (outgoing.fetched > 0)
            _outgoing.fetch.run(40);
    }, [outgoing.fetched]);
    react_1.useEffect(function () {
        var _transfers = __transfers.current;
        if (transfers.fetched > 0)
            _transfers.fetch.run(40);
    }, [transfers.fetched]);
    // on outgoing.fetch done
    react_1.useEffect(function () {
        var _swaps = __swaps.current;
        if (swaps.fetched > 0)
            _swaps.fetch.run(40);
    }, [swaps.fetched]);
    // on transfers.fetch command
    react_1.useEffect(function () {
        var transfers = __transfers.current;
        var block = __block.current;
        var fetchNextTransfers = __fetchNextTransfers.current;
        fetchNextTransfers({
            store: transfers,
            queryBuilder: transfersQuery,
            thresholdBlock: block - MAX_CONFIRMS,
        });
    }, [transfers.fetchCmd.is.ready]);
    // on swaps.fetch command
    react_1.useEffect(function () {
        var swaps = __swaps.current;
        var block = __block.current;
        var fetchNextTransfers = __fetchNextTransfers.current;
        fetchNextTransfers({
            store: swaps,
            queryBuilder: swapsQuery,
            thresholdBlock: block - MAX_CONFIRMS,
        });
    }, [swaps.fetchCmd.is.ready]);
    // on history.fetch command
    react_1.useEffect(function () {
        var history = __history.current;
        var block = __block.current;
        var fetchNextTransfers = __fetchNextTransfers.current;
        var watch = history.count > 0 ? 'ignore' : 'replace';
        fetchNextTransfers({
            store: history,
            queryBuilder: historyQuery,
            thresholdBlock: block - MAX_CONFIRMS,
            watch: watch,
        });
    }, [history.fetchCmd.is.ready]);
    // on incoming.fetch command
    react_1.useEffect(function () {
        var incoming = __incoming.current;
        var block = __block.current;
        var fetchNextTransfers = __fetchNextTransfers.current;
        fetchNextTransfers({
            store: incoming,
            queryBuilder: inboxQuery,
            thresholdBlock: block - MAX_CONFIRMS,
        });
    }, [incoming.fetchCmd.is.ready]);
    // on outgoing.fetch command
    react_1.useEffect(function () {
        var outgoing = __outgoing.current;
        var block = __block.current;
        var fetchNextTransfers = __fetchNextTransfers.current;
        fetchNextTransfers({
            store: outgoing,
            queryBuilder: outboxQuery,
            thresholdBlock: block - MAX_CONFIRMS,
        });
    }, [outgoing.fetchCmd.is.ready]);
    return react_1.default.createElement(react_1.default.Fragment, null, children);
});

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountStore = exports.Account = exports.Transfers = exports.CollectCmd = exports.RetrieveCmd = exports.FetchCmd = exports.swapDepositCmd = exports.DepositCmd = exports.ApprovedCmd = exports.DeviceInfo = exports.ERC20Tokens = exports.ERC20Token = exports.KiroToken = exports.Staking = exports.SafeTransfer = exports.DisconnectCmd = exports.ConnectCmd = exports.CmdStatus = exports.Transfer = exports.Swap = exports.Token = void 0;
var mobx_1 = require("mobx");
var bip39_1 = require("bip39");
var react_1 = require("@ionic/react");
var mobx_state_tree_1 = require("mobx-state-tree");
var web3_utils_1 = require("web3-utils");
var web3_1 = __importDefault(require("web3"));
var getChainName = function (chainId) {
    if (chainId === 1)
        return "main";
    if (chainId === 4)
        return "rinkeby";
    return "";
};
var StatePrimitive = mobx_state_tree_1.types.custom({
    name: "state",
    fromSnapshot: function (value) {
        return value;
    },
    toSnapshot: function (value) {
        return value;
    },
    isTargetType: function () {
        return true;
    },
    getValidationMessage: function () {
        return "";
        // if (/^-?\d+\.\d+$/.test(value)) return "" // OK
        // return `'${value}' doesn't look like a valid state`
    },
});
exports.Token = mobx_state_tree_1.types.model({
    address: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    decimals: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
    symbol: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    type: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
});
exports.Swap = mobx_state_tree_1.types.model({
    value: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    token: mobx_state_tree_1.types.optional(exports.Token, {}),
    fees: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
});
exports.Transfer = mobx_state_tree_1.types
    .model({
    id: mobx_state_tree_1.types.identifier,
    txid: mobx_state_tree_1.types.string,
    from: mobx_state_tree_1.types.string,
    to: mobx_state_tree_1.types.string,
    value: mobx_state_tree_1.types.string,
    fees: mobx_state_tree_1.types.string,
    salt: mobx_state_tree_1.types.string,
    secretHash: mobx_state_tree_1.types.string,
    state: StatePrimitive,
    updatedAt: mobx_state_tree_1.types.Date,
    confirmedBlock: mobx_state_tree_1.types.number,
    message: mobx_state_tree_1.types.string,
    token: mobx_state_tree_1.types.optional(exports.Token, {}),
    swap: mobx_state_tree_1.types.optional(exports.Swap, {}),
})
    .actions(function (self) { return ({
    update: function (state, txid) {
        self.updatedAt = new Date();
        self.state = state;
        if (txid)
            self.txid = txid;
    },
}); });
exports.CmdStatus = mobx_state_tree_1.types
    .model({
    ready: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    running: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    done: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    failed: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    withFailMessage: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    withId: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
})
    .actions(function (self) { return ({
    clear: function () {
        self.ready = false;
        self.running = false;
        self.done = false;
        self.failed = false;
        self.withFailMessage = "";
        self.withId = self.withId + 1;
    },
    prepared: function () {
        self.ready = true;
        self.running = false;
        self.done = false;
        self.failed = false;
        self.withFailMessage = "";
        self.withId = self.withId + 1;
    },
    started: function () {
        self.running = true;
        self.done = false;
        self.failed = false;
    },
    finished: function (err) {
        self.ready = false;
        self.running = false;
        if (err) {
            self.failed = true;
            self.withFailMessage = err.err.message;
        }
        else {
            self.done = true;
            self.failed = false;
            self.withFailMessage = "";
        }
    },
}); });
var CmdModel = {
    is: mobx_state_tree_1.types.optional(exports.CmdStatus, {}),
};
var CmdActions = function (self) { return ({
    start: function () {
        self.is.started();
    },
    done: function () {
        self.is.finished();
    },
    failed: function (_a) {
        var message = _a.message;
        self.is.finished({ err: { message: message } });
    },
    clearErrors: function () {
        self.is.failed = false;
        self.is.withFailMessage = "";
    },
    clear: function () {
        self.is.clear();
    },
}); };
var CmdBase = mobx_state_tree_1.types.model("CMDBase", CmdModel).actions(CmdActions);
exports.ConnectCmd = CmdBase.named("ConnectCmd")
    .props({
    connector: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    isConnected: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
})
    .actions(function (self) { return ({
    prepare: function (connector) {
        if (!connector) {
            self.isConnected = false;
            self.connector = "";
            return;
        }
        if (!self.is.running) {
            self.isConnected = true;
            self.connector = connector;
            self.is.prepared();
        }
    },
}); });
exports.DisconnectCmd = CmdBase.named("DisconnectCmd").actions(function (self) { return ({
    prepare: function () {
        if (!self.is.running) {
            self.is.prepared();
        }
    },
}); });
exports.SafeTransfer = mobx_state_tree_1.types
    .model("SafeTransfer", {
    address: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    synced: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    feesFormula: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    rewardFormula: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
})
    .volatile(function () { return ({
    fees: function (_value) { return "0"; },
    reward: function (_value, _stakingValue, _fees) { return "0"; },
}); })
    .actions(function (self) { return ({
    setData: function (data) {
        if (self.feesFormula !== data.feesFormula && data.feesFormula) {
            try {
                var formula_1 = JSON.parse(data.feesFormula);
                self.fees = function (value) {
                    return new Function(formula_1.arguments, formula_1.body)(web3_1.default.utils.toBN, web3_utils_1.toBN, value);
                };
                self.feesFormula = data.feesFormula;
            }
            catch (e) {
                console.log("zxc error", e);
            }
        }
        if (self.rewardFormula !== data.rewardFormula && data.rewardFormula) {
            try {
                var formula_2 = JSON.parse(data.rewardFormula);
                self.reward = function (value, stakingValue, fees) {
                    return new Function(formula_2.arguments, formula_2.body)(web3_1.default.utils.toBN, web3_utils_1.toBN, value, stakingValue, fees);
                };
                self.rewardFormula = data.rewardFormula;
            }
            catch (e) {
                console.log("zxc error", e);
            }
        }
        self.synced = data.synced;
        self.address = data.address;
    },
}); });
exports.Staking = mobx_state_tree_1.types
    .model("Staking", {
    address: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    balance: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
})
    .actions(function (self) { return ({
    setData: function (_a) {
        var address = _a.address;
        self.address = address;
    },
}); });
exports.KiroToken = mobx_state_tree_1.types
    .model("KiroToken", {
    address: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
})
    .actions(function (self) { return ({
    setData: function (_a) {
        var address = _a.address;
        self.address = address;
    },
}); });
exports.ERC20Token = mobx_state_tree_1.types
    .model("ERC20Token", {
    address: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    name: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    symbol: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    decimals: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 18),
    balance: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    rate: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
})
    .views(function (self) { return ({
    get tokenBalance() {
        return self.balance;
    },
}); })
    .actions(function (self) { return ({
    setData: function (_a) {
        var address = _a.address, name = _a.name, symbol = _a.symbol, decimals = _a.decimals, balance = _a.balance;
        self.address = address;
        self.name = name;
        self.symbol = symbol;
        self.decimals = decimals;
        self.balance = balance;
    },
    setBalance: function (balance) {
        self.balance = balance;
    },
    clearBalance: function () {
        self.balance = "";
    },
    setRate: function (rate) {
        self.rate = rate;
    },
}); });
exports.ERC20Tokens = mobx_state_tree_1.types
    .model("ERC20Token", {
    map: mobx_state_tree_1.types.map(exports.ERC20Token),
})
    .views(function (self) { return ({
    get list() {
        return Array.from(self.map.values());
    },
}); })
    .actions(function (self) { return ({
    addToken: function (_a) {
        var address = _a.address, name = _a.name, symbol = _a.symbol, decimals = _a.decimals, balance = _a.balance, rate = _a.rate;
        self.map.set(address, exports.ERC20Token.create({ address: address, name: name, symbol: symbol, decimals: decimals, balance: balance, rate: rate }));
    },
    setBalance: function (address, balance) {
        var _a;
        (_a = self.map.get(address)) === null || _a === void 0 ? void 0 : _a.setBalance(balance);
    },
    clearBalances: function () {
        self.map.forEach(function (erc20Token) { return erc20Token.clearBalance(); });
    },
    setRate: function (address, rate) {
        var _a;
        (_a = self.map.get(address)) === null || _a === void 0 ? void 0 : _a.setRate(rate);
    },
}); });
exports.DeviceInfo = mobx_state_tree_1.types
    .model("DeviceInfo", {
    isMobile: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, react_1.isPlatform("mobile")),
    haveMetaMask: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    ethereumProvider: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    loggedIn: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
})
    .actions(function (self) { return ({
    setData: function (_a) {
        var isMobile = _a.isMobile, haveMetaMask = _a.haveMetaMask, ethereumProvider = _a.ethereumProvider, loggedIn = _a.loggedIn;
        self.isMobile = isMobile;
        self.haveMetaMask = haveMetaMask;
        self.ethereumProvider = ethereumProvider;
        self.loggedIn = loggedIn;
    },
}); });
var EthAddressPrimitive = mobx_state_tree_1.types.custom({
    name: "Eth Address",
    fromSnapshot: function (value) {
        return value;
    },
    toSnapshot: function (value) {
        return value.toString();
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isTargetType: function (value) {
        return value instanceof String;
    },
    getValidationMessage: function (value) {
        if (value === "" || /^0x[a-fA-F0-9]{40}$/.test(value))
            return "";
        return "'" + value + "' doesn't look like a valid ethereum address";
    },
});
exports.ApprovedCmd = CmdBase.named('ApprovedCmd')
    .props({
    amount: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, '115792089237316195423570985008687907853269984665640564039457584007913129639935'),
    contractAddress: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ''),
})
    .actions(function (self) { return ({
    prepare: function (contractAddress) {
        if (!self.is.running) {
            self.contractAddress = contractAddress;
            self.is.prepared();
        }
    },
}); });
exports.DepositCmd = CmdBase.named("DepositCmd")
    .props({
    from: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    to: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    value: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    publicSalt: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    privateSalt: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    secretHash: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    message: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
})
    .actions(function (self) { return ({
    prepare: function (params) {
        if (!self.is.running) {
            self.from = params.from;
            self.to = params.to;
            self.value = params.value;
            self.message = params.message;
            self.privateSalt = params.privateSalt;
            self.publicSalt = params.publicSalt;
            self.secretHash = params.secretHash;
            self.is.prepared();
        }
    },
}); });
exports.swapDepositCmd = CmdBase.named("swapDepositCmd")
    .props({
    from: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    to: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    value: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    desiredValue: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    publicSalt: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    privateSalt: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    secretHash: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    message: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
})
    .actions(function (self) { return ({
    prepare: function (params) {
        if (!self.is.running) {
            self.from = params.from;
            self.to = params.to;
            self.value = params.value;
            self.desiredValue = params.desiredValue;
            self.message = params.message;
            self.privateSalt = params.privateSalt;
            self.publicSalt = params.publicSalt;
            self.secretHash = params.secretHash;
            self.is.prepared();
        }
    },
}); });
exports.FetchCmd = CmdBase.named("FetchCmd")
    .props({
    list: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    amount: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
})
    .actions(function (self) { return ({
    prepare: function (params) {
        if (!self.is.running) {
            self.list = params.list;
            self.amount = params.amount;
            self.is.prepared();
        }
    },
}); });
exports.RetrieveCmd = CmdBase.named('RetrieveCmd')
    .props({
    id: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ''),
})
    .actions(function (self) { return ({
    prepare: function (params) {
        if (!self.is.running) {
            self.id = params.id;
            self.is.prepared();
        }
    },
}); });
exports.CollectCmd = CmdBase.named("CollectCmd")
    .props({
    id: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    key: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
})
    .actions(function (self) { return ({
    prepare: function (params) {
        if (!self.is.running) {
            self.id = params.id;
            self.key = params.key;
            self.is.prepared();
        }
    },
}); });
exports.Transfers = mobx_state_tree_1.types
    .model('Transfers', {
    name: mobx_state_tree_1.types.string,
    map: mobx_state_tree_1.types.map(exports.Transfer),
    count: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
    fetched: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
    address: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ''),
    fetchCmd: mobx_state_tree_1.types.optional(exports.FetchCmd, {}),
})
    .views(function (self) { return ({
    get list() {
        return Array.from(self.map.values());
    },
    get fetch() {
        return {
            get is() {
                return createCommand(self.fetchCmd.is);
            },
            run: function (amount) {
                self.fetchCmd.prepare({ list: self.name, amount: amount });
            }
        };
    }
}); })
    .actions(function (self) { return ({
    setFetched: function (count) {
        self.fetched = count;
    },
    add: function (_a) {
        var address = _a.address, transfers = _a.transfers, count = _a.count;
        if (!self.address) {
            self.address = address;
        }
        else if (self.address !== address) {
            return;
        }
        for (var _i = 0, transfers_1 = transfers; _i < transfers_1.length; _i++) {
            var transfer = transfers_1[_i];
            self.map.put(exports.Transfer.create(transfer));
        }
        /*
          const newTransfers = new Map()
          transfers.map(transfer => {
            newTransfers.set(transfer.id, Transfer.create(transfer))
          })
          self.map.merge(newTransfers)
        */
        self.count = count;
    },
    upsert: function (address, transfer) {
        if (!self.address) {
            self.address = address;
        }
        else if (self.address !== address)
            return;
        if (!self.map.has(transfer.id)) {
            self.count = self.count + 1;
        }
        self.map.set(transfer.id, exports.Transfer.create(transfer));
    },
    update: function (address, transfer) {
        var _a;
        if (!self.address) {
            self.address = address;
        }
        else if (self.address !== address)
            return;
        (_a = self.map.get(transfer.id)) === null || _a === void 0 ? void 0 : _a.update(transfer.state, transfer === null || transfer === void 0 ? void 0 : transfer.txid);
    },
    delete: function (address, id) {
        if (self.address === address) {
            if (self.map.delete(id)) {
                self.count = self.count - 1;
            }
        }
    },
    remove: function (address, filter) {
        var res = [];
        if (self.address === address) {
            self.map.forEach(function (transfer) {
                if (filter(transfer)) {
                    res.push(mobx_state_tree_1.castToSnapshot(mobx_state_tree_1.getSnapshot(transfer)));
                    if (self.map.delete(transfer.id)) {
                        self.count = self.count - 1;
                    }
                }
            });
        }
        return res;
    },
    clear: function () {
        self.map.clear();
        self.fetched = 0;
        self.count = 0;
        // self.fetchId = self.fetchId + 1
        self.address = '';
        self.fetchCmd.clear();
    },
}); })
    .views(function (self) { return ({
    get list() {
        return (mobx_1.values(self.map)
            .filter(function () { return true; })
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .sort(function (a, b) {
            return a.updatedAt.getTime() < b.updatedAt.getTime()
                ? 1
                : a.updatedAt.getTime() === b.updatedAt.getTime()
                    ? 0
                    : -1;
        }));
    },
    get activeCount() {
        var count = 0;
        self.map.forEach(function (item) {
            if (item.state === 'new')
                count += 1;
        });
        return count;
    },
}); });
var Mnemonic = mobx_state_tree_1.types
    .model("Mnemonic", {
    data: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    clearCmd: mobx_state_tree_1.types.optional(CmdBase.named("ClearCmd"), {}),
    removeCmd: mobx_state_tree_1.types.optional(CmdBase.named("RemoveCmd"), {}),
    restoreCmd: mobx_state_tree_1.types.optional(CmdBase.named("RestoreCmd"), {}),
})
    .views(function (self) { return ({
    get clear() {
        return {
            get is() {
                return createCommand(self.clearCmd.is);
            },
            run: function () {
                self.clearCmd.is.prepared();
            }
        };
    },
    get remove() {
        return {
            get is() {
                return createCommand(self.removeCmd.is);
            },
            run: function () {
                self.removeCmd.is.prepared();
            }
        };
    },
    get restore() {
        return {
            get is() {
                return createCommand(self.restoreCmd.is);
            },
            run: function () {
                self.restoreCmd.is.prepared();
            }
        };
    }
}); })
    .actions(function (self) { return ({
    set: function (mnemonic) {
        self.data = mnemonic ? mnemonic : "";
    },
    clear: function () {
        self.clearCmd.is.prepared();
    },
    remove: function () {
        self.removeCmd.is.prepared();
    },
    restore: function () {
        self.restoreCmd.is.prepared();
    },
}); });
var WalletAddressCmd = CmdBase.named("WalletAddressCmd")
    .props({
    address: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
})
    .actions(function (self) { return ({
    prepare: function (address) {
        if (self.is.running)
            return;
        self.address = address ? address : "";
        self.is.prepared();
    },
}); });
var Wallet = mobx_state_tree_1.types
    .model("Wallet", {
    mnemonic: mobx_state_tree_1.types.optional(Mnemonic, {}),
    activeAccount: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    accounts: mobx_state_tree_1.types.array(mobx_state_tree_1.types.string),
    addAddressCmd: mobx_state_tree_1.types.optional(WalletAddressCmd, {}),
    removeAddressCmd: mobx_state_tree_1.types.optional(WalletAddressCmd, {}),
})
    .views(function (self) { return ({
    get removeAddress() {
        return {
            get is() {
                return createCommand(self.removeAddressCmd.is);
            },
            run: function (address) {
                self.removeAddressCmd.prepare(address);
            }
        };
    },
}); })
    .actions(function (self) { return ({
    addWalletAddress: function () {
        self.addAddressCmd.prepare();
    },
    setAccounts: function (accounts) {
        accounts.forEach(function (account) {
            self.accounts.push(account);
        });
    },
    setActiveAccount: function (activeAccount) {
        self.activeAccount = activeAccount || '';
    },
    generateMnemonic: function () {
        self.mnemonic.set(bip39_1.generateMnemonic());
    },
    setMnemonic: function (mnemonic) {
        self.mnemonic.set(mnemonic);
    },
    getMnemonic: function () {
        return self.mnemonic.data;
    },
    tryRestoreMnemonicFromStorage: function () {
        self.mnemonic.restore.run();
    },
    clearMnemonic: function () {
        self.mnemonic.clear.run();
    },
    removeMnemonic: function () {
        self.mnemonic.remove.run();
    },
    changeMnemonic: function (mnemonic) {
        self.mnemonic.set(mnemonic);
    },
}); });
var createCommand = function (is) { return ({
    get withFailMessage() {
        return is.withFailMessage;
    },
    get withId() {
        return is.withId;
    },
    get ready() {
        return is.ready;
    },
    get done() {
        return is.done;
    },
    get failed() {
        return is.failed;
    },
    get running() {
        return is.running;
    },
}); };
var createSecretHash = function (passcode) {
    var _publicSalt = new Uint16Array(10);
    var _privateSalt = new Uint16Array(10);
    window.crypto.getRandomValues(_publicSalt);
    window.crypto.getRandomValues(_privateSalt);
    var publicSalt = _publicSalt.join('');
    var privateSalt = _privateSalt.join('');
    var secretHash = web3_utils_1.sha3(web3_utils_1.sha3(privateSalt + web3_utils_1.sha3(publicSalt + passcode)) || "");
    return { privateSalt: privateSalt, publicSalt: publicSalt, secretHash: secretHash };
};
exports.Account = mobx_state_tree_1.types
    .model("Account", {
    allowance: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, "-1"),
    address: mobx_state_tree_1.types.optional(EthAddressPrimitive, ""),
    wallet: mobx_state_tree_1.types.optional(Wallet, {}),
    chainId: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, -1),
    active: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false),
    block: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, -1),
    balance: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    tokenBalance: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    stakingBalance: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ""),
    rate: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 0),
    history: mobx_state_tree_1.types.optional(exports.Transfers, { name: 'history' }),
    transfers: mobx_state_tree_1.types.optional(exports.Transfers, { name: "transfers" }),
    incoming: mobx_state_tree_1.types.optional(exports.Transfers, { name: "incoming" }),
    outgoing: mobx_state_tree_1.types.optional(exports.Transfers, { name: "outgoing" }),
    approvedCmd: mobx_state_tree_1.types.optional(exports.ApprovedCmd, {}),
    depositCmd: mobx_state_tree_1.types.optional(exports.DepositCmd, {}),
    retrieveCmd: mobx_state_tree_1.types.optional(exports.RetrieveCmd, {}),
    collectCmd: mobx_state_tree_1.types.optional(exports.CollectCmd, {}),
    connectCmd: mobx_state_tree_1.types.optional(exports.ConnectCmd, {}),
    disconnectCmd: mobx_state_tree_1.types.optional(exports.DisconnectCmd, {}),
    safeTransferMap: mobx_state_tree_1.types.map(exports.SafeTransfer),
    stakingMap: mobx_state_tree_1.types.map(exports.Staking),
    kiroTokenMap: mobx_state_tree_1.types.map(exports.KiroToken),
    ERC20TokensMap: mobx_state_tree_1.types.map(exports.ERC20Tokens),
    currency: mobx_state_tree_1.types.optional(exports.ERC20Token, {
        address: "0x000000000000",
        symbol: "ETH",
        decimals: 18,
        name: "Ethereum",
        balance: "",
    }),
    desiredCurrency: mobx_state_tree_1.types.optional(exports.ERC20Token, {
        address: '0xb1191f691a355b43542bea9b8847bc73e7abb137',
        symbol: 'KIRO',
        decimals: 18,
        name: 'Kirobo Token',
        balance: '',
    }),
    deviceInfo: mobx_state_tree_1.types.optional(exports.DeviceInfo, {}),
    left: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 10),
    factor: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 1),
    maxRewards: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.number, 10),
    gasPriceMap: mobx_state_tree_1.types.map(mobx_state_tree_1.types.string),
    safeSwapMap: mobx_state_tree_1.types.map(exports.SafeTransfer),
    canGetRewards: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, true),
    swapDepositCmd: mobx_state_tree_1.types.optional(exports.swapDepositCmd, {}),
    swaps: mobx_state_tree_1.types.optional(exports.Transfers, { name: 'swaps' }),
    swapRetrieveCmd: mobx_state_tree_1.types.optional(exports.RetrieveCmd, {}),
    swapCmd: mobx_state_tree_1.types.optional(exports.CollectCmd, {}),
    swapperAddress: mobx_state_tree_1.types.optional(EthAddressPrimitive, ''),
    swapperBalance: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, ''),
    formType: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.string, 'swap'),
})
    /**
     * views
     */
    .views(function (self) { return ({
    get retrieve() {
        return {
            get is() {
                return createCommand(self.retrieveCmd.is);
            },
            run: function (_a) {
                var id = _a.id;
                self.retrieveCmd.prepare({ id: id });
            },
            get data() {
                return {
                    get id() {
                        return self.retrieveCmd.id;
                    },
                };
            }
        };
    },
    get swapRetrieve() {
        return {
            get is() {
                return createCommand(self.swapRetrieveCmd.is);
            },
            run: function (_a) {
                var id = _a.id;
                self.swapRetrieveCmd.prepare({ id: id });
            },
            get data() {
                return {
                    get id() {
                        return self.swapRetrieveCmd.id;
                    },
                };
            }
        };
    },
    get deposit() {
        return {
            get is() {
                return createCommand(self.depositCmd.is);
            },
            run: function (_a) {
                var to = _a.to, value = _a.value, passcode = _a.passcode, _b = _a.message, message = _b === void 0 ? '' : _b;
                var _c = createSecretHash(passcode), secretHash = _c.secretHash, publicSalt = _c.publicSalt, privateSalt = _c.privateSalt;
                if (secretHash) {
                    self.depositCmd.prepare({
                        from: self.address,
                        to: to,
                        value: value,
                        message: message,
                        publicSalt: publicSalt,
                        privateSalt: privateSalt,
                        secretHash: secretHash,
                    });
                }
            },
            get data() {
                return {
                    get from() {
                        return self.depositCmd.from;
                    },
                    get to() {
                        return self.depositCmd.to;
                    },
                    get value() {
                        return self.depositCmd.value;
                    },
                    get publicSalt() {
                        return self.depositCmd.publicSalt;
                    },
                    get privateSalt() {
                        return self.depositCmd.privateSalt;
                    },
                    get secretHash() {
                        return self.depositCmd.secretHash;
                    },
                    get message() {
                        return self.depositCmd.message;
                    }
                };
            }
        };
    },
    get swapDeposit() {
        return {
            get is() {
                return createCommand(self.swapDepositCmd.is);
            },
            run: function (_a) {
                var to = _a.to, value = _a.value, desiredValue = _a.desiredValue, passcode = _a.passcode, _b = _a.message, message = _b === void 0 ? '' : _b;
                var _c = createSecretHash(passcode), secretHash = _c.secretHash, publicSalt = _c.publicSalt, privateSalt = _c.privateSalt;
                if (secretHash) {
                    self.swapDepositCmd.prepare({
                        from: self.address,
                        to: to,
                        value: value,
                        desiredValue: desiredValue,
                        message: message,
                        publicSalt: publicSalt,
                        privateSalt: privateSalt,
                        secretHash: secretHash,
                    });
                }
            },
            get data() {
                return {
                    get from() {
                        return self.swapDepositCmd.from;
                    },
                    get to() {
                        return self.swapDepositCmd.to;
                    },
                    get value() {
                        return self.swapDepositCmd.value;
                    },
                    get desiredValue() {
                        return self.swapDepositCmd.desiredValue;
                    },
                    get publicSalt() {
                        return self.swapDepositCmd.publicSalt;
                    },
                    get privateSalt() {
                        return self.swapDepositCmd.privateSalt;
                    },
                    get secretHash() {
                        return self.swapDepositCmd.secretHash;
                    },
                    get message() {
                        return self.swapDepositCmd.message;
                    }
                };
            }
        };
    },
    get collect() {
        return {
            get is() {
                return createCommand(self.collectCmd.is);
            },
            run: function (_a) {
                var id = _a.id, passcode = _a.passcode;
                var item = self.incoming.map.get(id);
                if (item && item.salt) {
                    var key = web3_utils_1.sha3(item.salt + passcode) || '';
                    self.collectCmd.prepare({ id: id, key: key });
                }
            },
            get data() {
                return {
                    get id() {
                        return self.collectCmd.id;
                    },
                    get key() {
                        return self.collectCmd.key;
                    }
                };
            }
        };
    },
    get swap() {
        return {
            get is() {
                return createCommand(self.swapCmd.is);
            },
            run: function (_a) {
                var id = _a.id, passcode = _a.passcode;
                var item = self.swaps.map.get(id);
                if (item && item.salt) {
                    var key = web3_utils_1.sha3(item.salt + passcode) || '';
                    self.swapCmd.prepare({ id: id, key: key });
                }
            },
            get data() {
                return {
                    get id() {
                        return self.swapCmd.id;
                    },
                    get key() {
                        return self.swapCmd.key;
                    }
                };
            }
        };
    },
    get approve() {
        return {
            get is() {
                return createCommand(self.approvedCmd.is);
            },
            run: function (contractAddress) {
                self.approvedCmd.prepare(contractAddress);
            },
            get data() {
                return {
                    get contractAddress() {
                        return self.approvedCmd.contractAddress;
                    }
                };
            }
        };
    },
    get connect() {
        return {
            get is() {
                return createCommand(self.connectCmd.is);
            },
            run: function (connector) {
                self.connectCmd.prepare(connector);
            },
            get data() {
                return {
                    get isConnected() {
                        return self.connectCmd.isConnected;
                    },
                    get connector() {
                        return self.connectCmd.connector;
                    }
                };
            }
        };
    },
    get disconnect() {
        return {
            get is() {
                return createCommand(self.disconnectCmd.is);
            },
            run: function () {
                self.disconnectCmd.prepare();
            },
        };
    },
    get safeTransferContract() {
        return self.safeTransferMap.get(getChainName(self.chainId));
    },
    get safeSwapContract() {
        return self.safeSwapMap.get(getChainName(self.chainId));
    },
    get kiroTokenContract() {
        return self.kiroTokenMap.get(getChainName(self.chainId));
    },
    get ERC20TokensContract() {
        var _a;
        return (((_a = self.ERC20TokensMap.get(getChainName(self.chainId > 0 ? self.chainId : 1))) === null || _a === void 0 ? void 0 : _a.list) || []);
    },
    get stakingContract() {
        return self.stakingMap.get(getChainName(self.chainId));
    },
    get gasPrice() {
        return (self.gasPriceMap.get(getChainName(self.chainId > 0 ? self.chainId : 1)) || '');
    },
    approvedToken: function (symbol, amount) {
        var toBN = web3_1.default.utils.toBN;
        var isApproved = !(symbol !== 'ETH' && toBN(self.allowance).cmp(toBN(amount)) === -1);
        // if (isApproved && self.approvedCmd.is.running) self.approvedCmd.done()
        return isApproved;
    },
    transferFees: function (amount) {
        var contract = self.formType !== 'swap'
            ? self.safeTransferMap.get(getChainName(self.chainId > 0 ? self.chainId : 1))
            : self.safeSwapMap.get(getChainName(self.chainId > 0 ? self.chainId : 1));
        if (contract)
            return contract.fees(parseFloat(amount) > 0 ? amount : '0');
        return '';
    },
    transferReward: function (amount, fees) {
        var contract = self.formType !== 'swap'
            ? self.safeTransferMap.get(getChainName(self.chainId > 0 ? self.chainId : 1))
            : self.safeSwapMap.get(getChainName(self.chainId > 0 ? self.chainId : 1));
        if (contract) {
            if (self.left <= 0)
                return 0;
            return (self.factor *
                +contract.reward(parseFloat(amount) ? amount : '0', self.stakingBalance || '0', parseFloat(fees) ? fees : '0'));
        }
        return '';
    },
    ERC20TokenList: function (chainName) {
        var tokens = self.ERC20TokensMap.get(chainName);
        return tokens ? tokens.list : [];
    },
}); })
    /**
     * actions
     */
    .actions(function (self) { return ({
    setCanGetRewards: function (canGetRewards) {
        self.canGetRewards = canGetRewards;
    },
    setFormType: function (formType) {
        self.formType = formType;
    },
    setAddress: function (address) {
        self.address = address;
    },
    setActive: function (newActive) {
        self.active = newActive;
    },
    setChainId: function (chainId) {
        self.chainId = chainId;
    },
    setBalance: function (balance) {
        self.balance = balance;
    },
    setTokenBalance: function (balance) {
        self.tokenBalance = balance;
    },
    setStakingBalance: function (balance) {
        self.stakingBalance = balance;
    },
    setBlock: function (block) {
        self.block = block;
    },
    setRate: function (newRate) {
        self.rate = newRate;
    },
    setCurrency: function (currency) {
        self.currency.setData(currency);
        var token = self.ERC20TokensContract.find(function (token) { var _a; return (token === null || token === void 0 ? void 0 : token.symbol) === ((_a = self.desiredCurrency) === null || _a === void 0 ? void 0 : _a.symbol); });
        if ((token === null || token === void 0 ? void 0 : token.symbol) === currency.symbol) {
            if (currency.symbol !== 'ETH') {
                var ethToken = self.ERC20TokensContract.find(function (token) { return (token === null || token === void 0 ? void 0 : token.symbol) === 'ETH'; });
                if (ethToken)
                    self.desiredCurrency.setData(ethToken);
            }
            else {
                var kiroToken = self.ERC20TokensContract.find(function (token) { return (token === null || token === void 0 ? void 0 : token.symbol) === 'KIRO'; });
                if (kiroToken)
                    self.desiredCurrency.setData(kiroToken);
            }
        }
    },
    setDesiredCurrency: function (currency) {
        self.desiredCurrency.setData(currency);
        var token = self.ERC20TokensContract.find(function (token) { var _a; return (token === null || token === void 0 ? void 0 : token.symbol) === ((_a = self.currency) === null || _a === void 0 ? void 0 : _a.symbol); });
        if ((token === null || token === void 0 ? void 0 : token.symbol) === currency.symbol) {
            if (currency.symbol !== 'ETH') {
                var ethToken = self.ERC20TokensContract.find(function (token) { return (token === null || token === void 0 ? void 0 : token.symbol) === 'ETH'; });
                if (ethToken)
                    self.currency.setData(ethToken);
            }
            else {
                var kiroToken = self.ERC20TokensContract.find(function (token) { return (token === null || token === void 0 ? void 0 : token.symbol) === 'KIRO'; });
                if (kiroToken)
                    self.currency.setData(kiroToken);
            }
        }
    },
    setCurrencyBalance: function (balance) {
        self.currency.setBalance(balance);
    },
    setAllowance: function (allowance) {
        self.allowance = allowance;
    },
    setDeviceInfo: function (deviceInfo) {
        self.deviceInfo.setData(deviceInfo);
    },
    setSafeTransferContract: function (chainName, data) {
        var _a;
        if (!chainName || !data) {
            return;
        }
        if (!self.safeTransferMap.has(chainName)) {
            self.safeTransferMap.set(chainName, exports.SafeTransfer.create());
        }
        var _b = data.address, address = _b === void 0 ? '' : _b, _c = data.feesFormula, feesFormula = _c === void 0 ? '' : _c, _d = data.rewardFormula, rewardFormula = _d === void 0 ? '' : _d, _e = data.synced, synced = _e === void 0 ? false : _e;
        (_a = self.safeTransferMap
            .get(chainName)) === null || _a === void 0 ? void 0 : _a.setData({ address: address, feesFormula: feesFormula, rewardFormula: rewardFormula, synced: synced });
    },
    setSafeSwapContract: function (chainName, data) {
        var _a;
        if (!chainName || !data)
            return;
        if (!self.safeSwapMap.has(chainName)) {
            self.safeSwapMap.set(chainName, exports.SafeTransfer.create());
        }
        var _b = data.address, address = _b === void 0 ? '' : _b, _c = data.feesFormula, feesFormula = _c === void 0 ? '' : _c, _d = data.rewardFormula, rewardFormula = _d === void 0 ? '' : _d, _e = data.synced, synced = _e === void 0 ? false : _e;
        (_a = self.safeSwapMap
            .get(chainName)) === null || _a === void 0 ? void 0 : _a.setData({ address: address, feesFormula: feesFormula, rewardFormula: rewardFormula, synced: synced });
    },
    setStakingContract: function (chainName, data) {
        var _a;
        if (!chainName || !data)
            return;
        if (!self.stakingMap.has(chainName)) {
            self.stakingMap.set(chainName, exports.Staking.create());
        }
        var _b = data.address, address = _b === void 0 ? '' : _b;
        (_a = self.stakingMap.get(chainName)) === null || _a === void 0 ? void 0 : _a.setData({ address: address });
    },
    setKiroTokenContract: function (chainName, data) {
        var _a;
        if (!chainName || !data)
            return;
        if (!self.kiroTokenMap.has(chainName)) {
            self.kiroTokenMap.set(chainName, exports.KiroToken.create());
        }
        var _b = data.address, address = _b === void 0 ? '' : _b;
        (_a = self.kiroTokenMap.get(chainName)) === null || _a === void 0 ? void 0 : _a.setData({ address: address });
    },
    setERC20TokenContract: function (chainName, data) {
        var _a;
        if (!chainName || !data)
            return;
        self.ERC20TokensMap.set(chainName, {});
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var _b = data_1[_i], address = _b.address, name_1 = _b.name, symbol = _b.symbol, decimals = _b.decimals, balance = _b.balance, rate = _b.rate;
            (_a = self.ERC20TokensMap.get(chainName)) === null || _a === void 0 ? void 0 : _a.addToken({
                address: address,
                name: name_1,
                symbol: symbol,
                decimals: decimals,
                balance: balance,
                rate: rate,
            });
        }
    },
    setERC20TokenBalance: function (chainName, address, balance) {
        var _a;
        (_a = self.ERC20TokensMap.get(chainName)) === null || _a === void 0 ? void 0 : _a.setBalance(address, balance);
    },
    setErc20TokenRate: function (chainName, address, rate) {
        var _a;
        (_a = self.ERC20TokensMap.get(chainName)) === null || _a === void 0 ? void 0 : _a.setRate(address, rate);
    },
    clearERC20TokenBalances: function (chainName) {
        var _a;
        chainName
            ? (_a = self.ERC20TokensMap.get(chainName)) === null || _a === void 0 ? void 0 : _a.clearBalances()
            : self.ERC20TokensMap.forEach(function (token) { return token.clearBalances(); });
    },
    setRewardsParams: function (factor, left) {
        self.factor = factor;
        self.left = left;
    },
    setMaxRewards: function (maxRewards) {
        self.maxRewards = maxRewards;
    },
    setGasPrice: function (chainName, gasPrice) {
        self.gasPriceMap.set(chainName, gasPrice);
    },
    setSwapperAddress: function (address) {
        self.swapperAddress = address;
    },
    setSwapperBalance: function (balance) {
        self.swapperBalance = balance;
    },
}); });
exports.accountStore = exports.Account.create();
/*
    Transfer
    API: v1/eth/networks ==> SafeTransfer Address, Fees & Reward formula
    Deposit:
      API: v1/eth/<network>/transfer/request  (from, to, value, publicSalt, privateSalt, secretHash, message) ==> fees + reward
      Contract: deposit(to, value, fees, secretHash) ==> transactionHash
      API: v1/eth/<network>/action/follow (txid)
    Retrieve:
      API: v1/eth/<network>/transfers (outgoing) ==> to, value, fees, secretHash
      Contract: retrieve(to, value, fees, secretHash)
    Collect:
      API: v1/eth/<network>/transfers (incoming) ==> id
      API: v1/eth/<network>/collect (id, key)
    secretHash = sha3(sha3(privateSalt + sha3(publicSalt + passcode))
*/

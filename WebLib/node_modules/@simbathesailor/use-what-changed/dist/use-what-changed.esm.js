import React from 'react';

var what_debug_changed = 0;
var configuration = {
  active: true
};
/**
 * Taken random color logic from some stackoverflow answer
 */


function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';

  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }

  return color;
}
/**
 *
 * Check whether the dependency item is an object. then
 */


var isObject = function isObject(t) {
  return Object.prototype.toString.call(t) === '[object Object]';
};

function getPrintableInfo(dependencyItem) {
  /**
   * Printing the info into viewable format
   */
  if (isObject(dependencyItem) || Array.isArray(dependencyItem)) {
    var ans;

    try {
      ans = JSON.stringify(dependencyItem, null, 2);
    } catch (e) {
      ans = 'CIRCULAR JSON';
    }

    return ans;
  }

  return dependencyItem;
} // const isDevelopment = process.env['NODE_ENV'] === 'development';


function useHotRefs(value) {
  var fnRef = React.useRef(value);
  React.useEffect(function () {
    fnRef.current = value;
  });
  return fnRef;
}

function useWhatChanged(dependency, dependencyNames, suffix, hookName) {
  // It's a fair assumption the hooks type will not change for a component during
  // its life time
  var hookNameFinal = React.useMemo(function () {
    if (hookName === "useLayoutEffect") {
      return "useLayoutEffect";
    } // if(hookName === "useEffect" || !hookName) {


    return "useEffect"; // }
  }, []); // This ref is responsible for book keeping of the old value

  var dependencyRef = React.useRef(dependency); // For count bookkeeping , for easy debugging

  var whatChangedHookCountRef = React.useRef(1); // For assigning color for easy debugging

  var backgroundColorRef = React.useRef('');
  var isDependencyArr = Array.isArray(dependencyRef.current);
  React[hookNameFinal](function () {
    if (dependencyRef.current && isDependencyArr // dependencyRef.current.length > 0
    ) {
        what_debug_changed++;
        whatChangedHookCountRef.current = what_debug_changed;
        backgroundColorRef.current = getRandomColor();
      } // const MyWindow: IWindow = window;

  }, [dependencyRef, isDependencyArr]);

  function postConsole() {
    console.log('\n');
    console.log("%c///// END SECTION/////", "background: " + backgroundColorRef.current + "; color: white; font-size: 10px", '\n');
    console.log('\n');
    console.log('\n');
  }

  function logBanners(_ref2) {
    var isFirstMount = _ref2.isFirstMount,
        suffixText = _ref2.suffixText,
        isBlankArrayAsDependency = _ref2.isBlankArrayAsDependency;

    if (configuration.active) {
      console.log("%c///// START SECTION /////", "background: " + backgroundColorRef.current + "; color: white; font-size: 10px", '\n');
      console.log('\n');
      console.log("%c " + whatChangedHookCountRef.current + " " + (suffix || ''), "background: " + backgroundColorRef.current + "; color: white; font-size: 10px", 'üëáüèæ', "" + (isFirstMount ? 'FIRST RUN' : 'UPDATES'), "" + suffixText);

      if (isBlankArrayAsDependency) {
        postConsole();
      }
    }
  }

  var longBannersRef = useHotRefs(logBanners);
  React[hookNameFinal](function () {
    if (!(dependencyRef.current && isDependencyArr)) {
      return;
    } // if (dependencyRef.current.length === 0) {
    //   return;
    // }
    // More info, if needed by user


    var stringSplitted = dependencyNames ? dependencyNames.split(',') : null;
    var changed = false;
    var whatChanged = dependency ? dependency.reduce(function (acc, dep, index) {
      if (dependencyRef.current && dep !== dependencyRef.current[index]) {
        var oldValue = dependencyRef.current[index];
        dependencyRef.current[index] = dep;

        if (dependencyNames && stringSplitted) {
          changed = true;
          acc["\"\u2705\" " + stringSplitted[index]] = {
            'Old Value': getPrintableInfo(oldValue),
            'New Value': getPrintableInfo(dep)
          };
        } else {
          acc["\"\u2705\" " + index] = {
            'Old Value': getPrintableInfo(oldValue),
            'New Value': getPrintableInfo(dep)
          };
        }

        return acc;
      }

      if (dependencyNames && stringSplitted) {
        acc["\"\u23FA\" " + stringSplitted[index]] = {
          'Old Value': getPrintableInfo(dep),
          'New Value': getPrintableInfo(dep)
        };
      } else {
        acc["\"\u23FA\" " + index] = {
          'Old Value': getPrintableInfo(dep),
          'New Value': getPrintableInfo(dep)
        };
      }

      return acc;
    }, {}) : {};

    if (configuration.active) {
      var isBlankArrayAsDependency = whatChanged && Object.keys(whatChanged).length === 0 && isDependencyArr;
      longBannersRef.current({
        isFirstMount: !changed,
        suffixText: isBlankArrayAsDependency ? " \uD83D\uDC49\uD83C\uDFFD This will run only once on mount." : "",
        isBlankArrayAsDependency: isBlankArrayAsDependency
      });

      if (!isBlankArrayAsDependency) {
        console.table(whatChanged);
        postConsole();
      }
    }
  }, [].concat(function () {
    if (dependency && isDependencyArr) {
      return dependency;
    }

    return [];
  }(), [dependencyRef, longBannersRef, hookName]));
}

export { useWhatChanged };
//# sourceMappingURL=use-what-changed.esm.js.map

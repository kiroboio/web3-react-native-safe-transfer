"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bootstrap = void 0;
const fs = __importStar(require("fs"));
const progress_1 = __importDefault(require("progress"));
const typedoc_1 = require("typedoc");
const plugins_1 = require("typedoc/dist/lib/converter/plugins");
const events_1 = require("typedoc/dist/lib/output/events");
const options_1 = require("./options");
const CATEGORY_POSITION = {
    [typedoc_1.ReflectionKind.Module]: 1,
    [typedoc_1.ReflectionKind.Namespace]: 1,
    [typedoc_1.ReflectionKind.Enum]: 2,
    [typedoc_1.ReflectionKind.Class]: 3,
    [typedoc_1.ReflectionKind.Interface]: 4,
    [typedoc_1.ReflectionKind.TypeAlias]: 5,
    [typedoc_1.ReflectionKind.Variable]: 6,
    [typedoc_1.ReflectionKind.Function]: 7,
    [typedoc_1.ReflectionKind.ObjectLiteral]: 8,
};
const bootstrap = (app, opts) => {
    addTypedocReaders(app);
    addTypedocDeclarations(app);
    app.renderer.render = render;
    app.bootstrap({ ...options_1.getPluginOptions(opts) });
    return app.options.getRawValues();
};
exports.bootstrap = bootstrap;
async function render(project, outputDirectory) {
    var _a;
    if (!this.prepareTheme() ||
        !isOutputDirectory(this.application, outputDirectory)) {
        return;
    }
    const output = new events_1.RendererEvent(events_1.RendererEvent.BEGIN, outputDirectory, project);
    const options = this.application.options.getRawValues();
    output.settings = options;
    output.urls = this.theme.getUrls(project);
    if (output.urls) {
        const bar = new progress_1.default('Rendering [:bar] :percent', {
            total: output.urls.length,
            width: 40,
        });
        this.trigger(output);
        if (!output.isDefaultPrevented) {
            (_a = output.urls) === null || _a === void 0 ? void 0 : _a.forEach((mapping, i) => {
                this.renderDocument(output.createPageEvent(mapping));
                bar.tick();
            });
            this.trigger(events_1.RendererEvent.END, output);
        }
        writeCategoryYaml(outputDirectory, options.sidebar.categoryLabel, options.sidebar.position);
        Object.keys(groupUrlsByKind(output.urls)).forEach((group) => {
            const kind = parseInt(group);
            const mapping = this.theme.mappings.find((mapping) => mapping.kind.includes(kind));
            if (mapping) {
                writeCategoryYaml(outputDirectory + '/' + mapping.directory, plugins_1.GroupPlugin.getKindPlural(kind), CATEGORY_POSITION[kind]);
            }
        });
    }
}
const isOutputDirectory = (app, outputDirectory) => {
    const options = app.options.getRawValues();
    if (options.disableOutputCheck) {
        return true;
    }
    if (!fs.existsSync(outputDirectory)) {
        return true;
    }
    if (app.renderer.theme.isOutputDirectory(outputDirectory)) {
        if (fs.existsSync(outputDirectory)) {
            fs.rmdirSync(outputDirectory, { recursive: true });
        }
        return true;
    }
    else {
        app.logger.error(`The output directory "${outputDirectory}" exists but does not seem to be a documentation generated by TypeDoc.\n` +
            'Make sure this is the right target directory, delete the folder and rerun TypeDoc.');
        return false;
    }
};
const writeCategoryYaml = (categoryPath, label, position) => {
    const yaml = [`label: "${label}"`];
    if (position !== null) {
        yaml.push(`position: ${position}`);
    }
    if (fs.existsSync(categoryPath)) {
        fs.writeFileSync(categoryPath + '/_category_.yml', yaml.join('\n'));
    }
};
const groupUrlsByKind = (urls) => {
    return urls.reduce((r, v, i, a, k = v.model.kind) => ((r[k] || (r[k] = [])).push(v), r), {});
};
const addTypedocReaders = (app) => {
    app.options.addReader(new typedoc_1.TypeDocReader());
    app.options.addReader(new typedoc_1.TSConfigReader());
};
const addTypedocDeclarations = (app) => {
    app.options.addDeclaration({
        name: 'id',
    });
    app.options.addDeclaration({
        name: 'docsRoot',
    });
    app.options.addDeclaration({
        name: 'siteDir',
    });
    app.options.addDeclaration({
        name: 'globalsTitle',
    });
    app.options.addDeclaration({
        name: 'readmeTitle',
    });
    app.options.addDeclaration({
        name: 'sidebar',
        type: typedoc_1.ParameterType.Mixed,
    });
};

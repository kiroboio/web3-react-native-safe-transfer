"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSearchIndex = void 0;
/**
 * Creates a search index for the passed {@link Tree}
 *
 * @param tree - the tree for which the index gets generated
 * @param config - the config that gets used
 * @returns the search index, containing all linked members of the docs
 *
 * @example
 * ```ts
 * console.log(getSearchIndex(tree))
 * ```
 */
function getSearchIndex(tree, config) {
    const res = [];
    Object.keys(tree).forEach(moduleName => {
        res.push({
            name: moduleName,
            text: moduleName,
            url: `${config.baseUrl}${moduleName}`
        });
        const moduleTree = tree[moduleName];
        res.push(...getSearchIndexForModuleMembers(moduleTree, moduleName, config));
    });
    return res;
}
exports.getSearchIndex = getSearchIndex;
/**
 * Creates a search index for all members of the passed module node
 *
 * @param moduleTree - the module tree node
 * @param moduleName - the module's name
 * @param config - the current config with which the search index gets created
 * @returns the search index of the class members
 *
 * @example
 * ```ts
 * const searchIndex = []
 * searchIndex.push(...getSearchIndexForModuleMembers(
 * 	moduleTree,
 * 	`${moduleName}`
 * 	config
 * ));
 * ```
 */
function getSearchIndexForModuleMembers(moduleTree, moduleName, config) {
    const res = [];
    moduleTree.forEach(moduleMember => {
        res.push({
            name: moduleMember.name,
            text: moduleName + '#' + moduleMember.name,
            url: `${config.baseUrl}${moduleName}#${moduleMember.name}`
        });
        res.push(...getSearchIndexForModuleMemberChildren(moduleMember.declarations, moduleName + '#' + moduleMember.name, config));
    });
    return res;
}
/**
 * Creates a search index for all children of a module member's declarations.
 *
 * @param declarations - the declarations of the module member
 * @param prefix - the prefix of the module, e.g., `[module-name].[member-name]`
 * @param config - the current config with which the search index gets created
 * @returns the search index for all children of the `declarations`
 *
 * @example
 * ```ts
 * index.push(
 * 	..getSearchIndexForModuleMemberChildren(
 * 	moduleMember.declarations,
 * 	moduleName + '.' + moduleMember.name,
 * 	config
 * );
 * ```
 */
function getSearchIndexForModuleMemberChildren(declarations, prefix, config) {
    const res = [];
    for (const node of declarations) {
        if (isType(node, 'class') ||
            isType(node, 'interface')) {
            res.push(...getSearchResultsForInterfaceAndClassMembers(node, prefix, config));
        }
    }
    return res;
}
/**
 * Creates a search index for all members of the passed interface or class declaration node
 *
 * @param node - the interface declaration node
 * @param prefix - the module for the absolute name
 * @param config - the current config with which the search index gets created
 * @returns the search index of the interface members
 *
 * @example
 * ```ts
 * const searchIndex = []
 * if (isInterfaceDeclaration(interfaceNode) || isClassDeclaration(InterfaceNode))
 * 	searchIndex.push(...getSearchResultsForInterfaceAndClassMembers(
 * 		interfaceNode,
 * 		`${moduleName}.${$moduleMember.name}`,
 * 		config
 * 	));
 * ```
 */
function getSearchResultsForInterfaceAndClassMembers(node, prefix, config) {
    var _a, _b;
    const res = [];
    const interfaceDeclaration = node.declarations[0];
    const memberToSearchResult = (property) => {
        res.push({
            name: property.name,
            text: `${prefix}.${property.name}`,
            url: `${config.baseUrl}${prefix}.${property.name}`
        });
    };
    (_a = interfaceDeclaration.properties) === null || _a === void 0 ? void 0 : _a.forEach(memberToSearchResult);
    (_b = interfaceDeclaration.methods) === null || _b === void 0 ? void 0 : _b.forEach(memberToSearchResult);
    return res;
}
/**
 * Checks if the given node is a {@link ModuleTreeNode} contains a class declaration
 *
 * @param node - the node
 * @param typeName - the `node.type` for the type T
 * @typeparam T - the type of `node.declarations[0]`, if `node.type === typeName`
 * @returns does `node.declarations` contain a class declaration?
 *
 * @example
 * ```ts
 * if (isType<ClassDeclarationStructure>(node, 'class')) {
 *     // node.declarations[0] is a ClassDeclarationStructure
 * } else if (isType<InterfaceDeclarationStructure>(node, 'Interface')) {
 *     // node.declarations[0] is a InterfaceDeclarationStructure
 * }
 * ```
 */
function isType(node, typeName) {
    return node.type === typeName;
}
//# sourceMappingURL=searchIndex.js.map